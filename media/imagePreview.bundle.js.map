{
  "version": 3,
  "sources": ["wasm/tiff-wasm.js", "modules/settings-manager.js", "modules/normalization-helper.js", "modules/tiff-wasm-wrapper.js", "modules/tiff-processor.js", "modules/exr-processor.js", "modules/npy-processor.js", "modules/pfm-processor.js", "modules/ppm-processor.js", "modules/png-processor.js", "modules/zoom-controller.js", "modules/mouse-handler.js", "modules/histogram-overlay.js", "modules/colormap-converter.js", "imagePreview.js"],
  "sourcesContent": ["let wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    }\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_externrefs.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n/**\n * Decode a TIFF file from an ArrayBuffer\n * Returns TiffResult with image data and metadata\n * @param {Uint8Array} data\n * @returns {TiffResult}\n */\nexport function decode_tiff(data) {\n    const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.decode_tiff(ptr0, len0);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return TiffResult.__wrap(ret[0]);\n}\n\nconst TiffResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tiffresult_free(ptr >>> 0, 1));\n/**\n * Result type for TIFF decoding operations\n */\nexport class TiffResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TiffResult.prototype);\n        obj.__wbg_ptr = ptr;\n        TiffResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TiffResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tiffresult_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get compression() {\n        const ret = wasm.tiffresult_compression(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get sample_format() {\n        const ret = wasm.tiffresult_sample_format(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get raw data as bytes (for transferring to JS)\n     * @returns {Uint8Array}\n     */\n    get_data_bytes() {\n        const ret = wasm.tiffresult_get_data_bytes(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * @returns {number}\n     */\n    get bits_per_sample() {\n        const ret = wasm.tiffresult_bits_per_sample(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get data as Float32Array (most common for visualization)\n     * @returns {Float32Array}\n     */\n    get_data_as_f32() {\n        const ret = wasm.tiffresult_get_data_as_f32(this.__wbg_ptr);\n        var v1 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n    /**\n     * @returns {number}\n     */\n    get planar_configuration() {\n        const ret = wasm.tiffresult_planar_configuration(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get photometric_interpretation() {\n        const ret = wasm.tiffresult_photometric_interpretation(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get width() {\n        const ret = wasm.tiffresult_width(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get height() {\n        const ret = wasm.tiffresult_height(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get channels() {\n        const ret = wasm.tiffresult_channels(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get max_value() {\n        const ret = wasm.tiffresult_max_value(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get min_value() {\n        const ret = wasm.tiffresult_min_value(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get predictor() {\n        const ret = wasm.tiffresult_predictor(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) TiffResult.prototype[Symbol.dispose] = TiffResult.prototype.free;\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg___wbindgen_throw_b855445ff6a94295 = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_log_8cec76766b8c0e33 = function(arg0) {\n        console.log(arg0);\n    };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return ret;\n    };\n    imports.wbg.__wbg_now_793306c526e2e3b6 = function() {\n        const ret = Date.now();\n        return ret;\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {\n        // Cast intrinsic for `Ref(String) -> Externref`.\n        const ret = getStringFromWasm0(arg0, arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_externrefs;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedFloat32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm/tiff-wasm.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n", "// @ts-check\n\"use strict\";\n\n/**\n * @typedef {Object} NormalizationSettings\n * @property {number} min\n * @property {number} max\n * @property {boolean} autoNormalize\n * @property {boolean} gammaMode\n */\n\n/**\n * @typedef {Object} GammaSettings\n * @property {number} in\n * @property {number} out\n */\n\n/**\n * @typedef {Object} BrightnessSettings\n * @property {number} offset\n */\n\n/**\n * @typedef {Object} MaskFilterSettings\n * @property {string} maskUri\n * @property {number} threshold\n * @property {boolean} filterHigher\n * @property {boolean} enabled\n */\n\n/**\n * @typedef {Object} ImageSettings\n * @property {NormalizationSettings} [normalization]\n * @property {GammaSettings} [gamma]\n * @property {BrightnessSettings} [brightness]\n * @property {MaskFilterSettings[]} [maskFilters]\n * @property {string} [nanColor]\n * @property {boolean} [rgbAs24BitGrayscale]\n * @property {number} [scale24BitFactor]\n * @property {boolean} [normalizedFloatMode]\n * @property {boolean} [colorPickerShowModified]\n * @property {string} [resourceUri]\n * @property {string} [src]\n */\n\n/**\n * Settings Manager Module\n * Handles application settings and configuration\n */\nexport class SettingsManager {\n  constructor() {\n    /** @type {ImageSettings} */\n    this._settings = this._loadSettings();\n    /** @type {{PIXELATION_THRESHOLD: number, SCALE_PINCH_FACTOR: number, MAX_SCALE: number, MIN_SCALE: number, ZOOM_LEVELS: number[]}} */\n    this._constants = {\n      PIXELATION_THRESHOLD: 3,\n      SCALE_PINCH_FACTOR: 0.075,\n      MAX_SCALE: 200,\n      MIN_SCALE: 0.1,\n      ZOOM_LEVELS: [\n        0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.5, 2, 3, 5, 7, 10, 15,\n        20, 30, 50, 70, 100, 200,\n      ],\n    };\n    /** @type {boolean} */\n    this._isMac = navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0;\n  }\n\n  /**\n   * Load settings from the DOM\n   * @private\n   * @returns {ImageSettings}\n   */\n  _loadSettings() {\n    const element = document.getElementById(\"image-preview-settings\");\n    if (element) {\n      const data = element.getAttribute(\"data-settings\");\n      if (data) {\n        return JSON.parse(data);\n      }\n    }\n    throw new Error(\"Could not load settings\");\n  }\n\n  /**\n   * Get application settings\n   * @returns {ImageSettings}\n   */\n  get settings() {\n    return this._settings;\n  }\n\n  /**\n   * Get application constants\n   * @returns {{PIXELATION_THRESHOLD: number, SCALE_PINCH_FACTOR: number, MAX_SCALE: number, MIN_SCALE: number, ZOOM_LEVELS: number[]}}\n   */\n  get constants() {\n    return this._constants;\n  }\n\n  /**\n   * Check if running on Mac\n   * @returns {boolean}\n   */\n  get isMac() {\n    return this._isMac;\n  }\n\n  /**\n   * Update settings from new data (for real-time updates)\n   * @param {ImageSettings} newSettings - New settings object\n   * @returns {{parametersOnly: boolean, changedMasks: boolean, changedStructure: boolean}} - What changed\n   */\n  updateSettings(newSettings) {\n    if (!newSettings) {\n      return { parametersOnly: false, changedMasks: false, changedStructure: false };\n    }\n\n    // Track what changed\n    const changes = {\n      parametersOnly: false,\n      changedMasks: false,\n      changedStructure: false\n    };\n\n    // Check if only parameters changed (gamma, brightness, normalization ranges)\n    const oldSettings = this._settings;\n\n    // Check parameter changes\n    const gammaChanged = JSON.stringify(oldSettings.gamma) !== JSON.stringify(newSettings.gamma);\n    const brightnessChanged = JSON.stringify(oldSettings.brightness) !== JSON.stringify(newSettings.brightness);\n    const normRangeChanged = oldSettings.normalization?.min !== newSettings.normalization?.min ||\n      oldSettings.normalization?.max !== newSettings.normalization?.max;\n    const normAutoChanged = oldSettings.normalization?.autoNormalize !== newSettings.normalization?.autoNormalize;\n    const normGammaModeChanged = oldSettings.normalization?.gammaMode !== newSettings.normalization?.gammaMode;\n\n    // Check structural changes\n    const masksChanged = JSON.stringify(oldSettings.maskFilters || []) !== JSON.stringify(newSettings.maskFilters || []);\n    const rgbModeChanged = oldSettings.rgbAs24BitGrayscale !== newSettings.rgbAs24BitGrayscale;\n    const scaleModeChanged = oldSettings.scale24BitFactor !== newSettings.scale24BitFactor;\n    const floatModeChanged = oldSettings.normalizedFloatMode !== newSettings.normalizedFloatMode;\n    const nanColorChanged = (oldSettings.nanColor ?? 'black') !== (newSettings.nanColor ?? 'black');\n\n    // Determine change type\n    if (masksChanged) {\n      changes.changedMasks = true;\n    }\n\n    if (rgbModeChanged || scaleModeChanged || floatModeChanged) {\n      changes.changedStructure = true;\n    }\n\n    // Determine if anything changed at all\n    const somethingChanged = gammaChanged || brightnessChanged || normRangeChanged ||\n      normAutoChanged || normGammaModeChanged || masksChanged ||\n      rgbModeChanged || scaleModeChanged || floatModeChanged || nanColorChanged;\n\n    // If only gamma, brightness, normalization ranges, or nanColor changed, it's parameters-only\n    // Also treat \"no changes\" as parameters-only to avoid unnecessary slow path\n    if (!somethingChanged ||\n      ((gammaChanged || brightnessChanged || normRangeChanged || normAutoChanged || normGammaModeChanged || nanColorChanged) &&\n        !masksChanged && !rgbModeChanged && !scaleModeChanged && !floatModeChanged)) {\n      changes.parametersOnly = true;\n    } else {\n      console.log('\u26A0\uFE0F Structural changes detected:', {\n        masksChanged,\n        rgbModeChanged,\n        scaleModeChanged,\n        floatModeChanged,\n        nanColorChanged\n      });\n    }\n\n    // Deep merge to ensure nested objects are fully replaced\n    this._settings = {\n      ...this._settings,\n      ...newSettings,\n      normalization: newSettings.normalization\n        ? { ...newSettings.normalization }\n        : this._settings.normalization,\n      gamma: newSettings.gamma\n        ? { ...newSettings.gamma }\n        : this._settings.gamma,\n      brightness: newSettings.brightness\n        ? { ...newSettings.brightness }\n        : this._settings.brightness,\n      maskFilters: newSettings.maskFilters\n        ? [...newSettings.maskFilters]\n        : this._settings.maskFilters,\n    };\n\n    return changes;\n  }\n}\n", "// @ts-check\n\"use strict\";\n\n/**\n * Helper class for normalization, gamma, and brightness corrections.\n * Centralizes logic for range calculation and LUT generation.\n */\nexport class NormalizationHelper {\n    /**\n     * Calculate the normalization range (min/max) based on settings and stats.\n     * @param {Object} settings - Image settings\n     * @param {Object} stats - Image statistics {min, max}\n     * @param {number} typeMax - Maximum value for the data type (e.g., 255, 65535, or 1.0 for float)\n     * @param {boolean} isFloat - Whether the image data is floating point\n     * @returns {{min: number, max: number}} Calculated min/max range\n     */\n    static getNormalizationRange(settings, stats, typeMax, isFloat = false) {\n        let normMin, normMax;\n\n        if (settings.normalization && settings.normalization.autoNormalize) {\n            // Auto-normalize: use stats\n            // Fallback to 0-typeMax if stats are missing/invalid\n            normMin = (stats && Number.isFinite(stats.min)) ? stats.min : 0;\n            normMax = (stats && Number.isFinite(stats.max)) ? stats.max : typeMax;\n        } else if (settings.normalization && settings.normalization.gammaMode) {\n            // Gamma mode: use full range of the type\n            normMin = 0;\n            normMax = typeMax;\n        } else if (settings.normalization && (settings.normalization.min !== undefined && settings.normalization.max !== undefined)) {\n            // Manual mode: use user-specified range\n            normMin = settings.normalization.min;\n            normMax = settings.normalization.max;\n\n            // If normalized float mode is enabled for integer images, scale up the range\n            // (User provides 0.0-1.0, we map to 0-typeMax)\n            if (settings.normalizedFloatMode && !isFloat) {\n                normMin *= typeMax;\n                normMax *= typeMax;\n            }\n        } else {\n            // Default fallback (usually behaves like gamma mode)\n            normMin = 0;\n            normMax = typeMax;\n        }\n\n        return { min: normMin, max: normMax };\n    }\n\n    /**\n     * Apply gamma and brightness corrections to a normalized value (0-1).\n     * @param {number} normalized - Value in range 0-1\n     * @param {Object} settings - Settings object with gamma and brightness\n     * @returns {number} Corrected value (may be outside [0,1])\n     */\n    static applyGammaAndBrightness(normalized, settings) {\n        const gammaIn = settings.gamma?.in ?? 1.0;\n        const gammaOut = settings.gamma?.out ?? 1.0;\n        const exposureStops = settings.brightness?.offset ?? 0;\n\n        // Apply input gamma (linearize)\n        let linear = Math.pow(normalized, gammaIn);\n\n        // Apply exposure (brightness)\n        linear *= Math.pow(2, exposureStops);\n\n        // Apply output gamma (encode)\n        const output = Math.pow(linear, 1.0 / gammaOut);\n\n        return output;\n    }\n\n    /**\n     * Generate a lookup table for gamma and brightness corrections.\n     * @param {Object} settings - Settings object\n     * @param {number} bitDepth - Bit depth (8 or 16)\n     * @param {number} maxValue - Maximum input value (255 or 65535)\n     * @param {number} normMin - Normalization minimum\n     * @param {number} normMax - Normalization maximum\n     * @returns {Uint8Array} LUT array mapping input values to output 0-255\n     */\n    static generateLut(settings, bitDepth, maxValue, normMin, normMax) {\n        const perfStart = performance.now();\n        const lutSize = maxValue + 1;\n        const lut = new Uint8Array(lutSize);\n        const range = normMax - normMin;\n        const invRange = range > 0 ? 1.0 / range : 0;\n\n        for (let i = 0; i < lutSize; i++) {\n            // Map input value to normalized float range\n            const value = i;\n            let normalized = (value - normMin) * invRange;\n\n            // Apply gamma and brightness\n            normalized = this.applyGammaAndBrightness(normalized, settings);\n\n            // Clamp and convert to 0-255\n            const output = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n            lut[i] = output;\n        }\n\n        console.log(`[LUT] ${bitDepth}-bit LUT generation took ${(performance.now() - perfStart).toFixed(2)}ms`);\n        return lut;\n    }\n\n    /**\n     * Check if the transformation is identity (no effective gamma/brightness changes).\n     * Identity occurs when gammaIn === gammaOut (they cancel out) and brightness is 0.\n     * This is because (value^gammaIn)^(1/gammaOut) = value when gammaIn === gammaOut.\n     * @param {Object} settings - Settings object\n     * @returns {boolean} True if identity transformation\n     */\n    static isIdentityTransformation(settings) {\n        const gammaIn = settings.gamma?.in ?? 1.0;\n        const gammaOut = settings.gamma?.out ?? 1.0;\n        const exposureStops = settings.brightness?.offset ?? 0;\n\n        // Identity when gammaIn equals gammaOut (they cancel) and no brightness adjustment\n        return Math.abs(gammaIn - gammaOut) < 0.001 &&\n            Math.abs(exposureStops) < 0.001;\n    }\n\n    /**\n     * Calculate the effective input range that maps to the visible output range (0-1).\n     * Values outside this range will be clipped to 0 or 1.\n     * This allows skipping expensive calculations for clipped pixels.\n     * \n     * @param {Object} settings - Image settings\n     * @param {number} normMin - Normalization minimum\n     * @param {number} normMax - Normalization maximum\n     * @returns {{min: number, max: number}} Effective input range\n     */\n    static getEffectiveVisualizationRange(settings, normMin, normMax) {\n        const gammaIn = settings.gamma?.in ?? 1.0;\n        const gammaOut = settings.gamma?.out ?? 1.0;\n        const exposureStops = settings.brightness?.offset ?? 0;\n        const range = normMax - normMin;\n\n        // If identity transform, effective range is just the normalization range\n        if (this.isIdentityTransformation(settings)) {\n            return { min: normMin, max: normMax };\n        }\n\n        // We want to find input values V such that:\n        // Output(V) = 0  =>  V_min\n        // Output(V) = 1  =>  V_max\n\n        // The forward transform is:\n        // 1. normalized = (V - normMin) / range\n        // 2. linear = normalized ^ gammaIn\n        // 3. exposed = linear * 2^exposure\n        // 4. output = exposed ^ (1/gammaOut)\n\n        // Reversing for Output = 0:\n        // 0 = exposed ^ (1/gammaOut) => exposed = 0\n        // 0 = linear * 2^exposure => linear = 0\n        // 0 = normalized ^ gammaIn => normalized = 0\n        // 0 = (V - normMin) / range => V = normMin\n        // So V_min is always normMin (unless we have negative exposure/gamma weirdness, but usually 0 maps to 0)\n        const vMin = normMin;\n\n        // Reversing for Output = 1:\n        // 1 = exposed ^ (1/gammaOut) => exposed = 1\n        // 1 = linear * 2^exposure => linear = 1 / 2^exposure = 2^(-exposure)\n        // linear = normalized ^ gammaIn => normalized = linear ^ (1/gammaIn)\n        // normalized = (2^(-exposure)) ^ (1/gammaIn)\n        // V = normalized * range + normMin\n\n        const exposureFactor = Math.pow(2, exposureStops);\n        // If exposure is very high, we see very dark things. If exposure is low, we only see bright things.\n\n        // Let's trace back from Output=1\n        // exposed = 1\n        // linear = 1 / exposureFactor\n        const linearThreshold = 1.0 / exposureFactor;\n\n        // normalized = linearThreshold ^ (1/gammaIn)\n        const normalizedThreshold = Math.pow(linearThreshold, 1.0 / gammaIn);\n\n        // V = normalizedThreshold * range + normMin\n        const vMax = normalizedThreshold * range + normMin;\n\n        return { min: vMin, max: vMax };\n    }\n}\n\n/**\n * Centralized statistics calculator for image data.\n * Eliminates duplication across processors.\n */\nexport class ImageStatsCalculator {\n    /**\n     * Calculate min/max statistics for float data.\n     * @param {Float32Array} data - Image data\n     * @param {number} width - Image width  \n     * @param {number} height - Image height\n     * @param {number} channels - Number of channels\n     * @returns {{min: number, max: number}} Statistics\n     */\n    static calculateFloatStats(data, width, height, channels) {\n        const perfStart = performance.now();\n        let minVal = Infinity;\n        let maxVal = -Infinity;\n\n        const len = width * height;\n        for (let i = 0; i < len; i++) {\n            for (let c = 0; c < Math.min(channels, 3); c++) {\n                const val = data[i * channels + c];\n                if (Number.isFinite(val)) {\n                    if (val < minVal) minVal = val;\n                    if (val > maxVal) maxVal = val;\n                }\n            }\n        }\n\n        console.log(`[Stats] Float stats calculation took ${(performance.now() - perfStart).toFixed(2)}ms`);\n        return { min: minVal, max: maxVal };\n    }\n\n    /**\n     * Calculate min/max statistics for integer data.\n     * @param {Uint8Array|Uint16Array} data - Image data\n     * @param {number} width - Image width\n     * @param {number} height - Image height\n     * @param {number} channels - Number of channels\n     * @returns {{min: number, max: number}} Statistics\n     */\n    static calculateIntegerStats(data, width, height, channels) {\n        let minVal = Infinity;\n        let maxVal = -Infinity;\n\n        const len = width * height;\n        for (let i = 0; i < len; i++) {\n            for (let c = 0; c < Math.min(channels, 3); c++) {\n                const val = data[i * channels + c];\n                if (val < minVal) minVal = val;\n                if (val > maxVal) maxVal = val;\n            }\n        }\n\n        return { min: minVal, max: maxVal };\n    }\n}\n\n/**\n * Centralized image renderer for all data types (uint8, uint16, float32).\n * Handles normalization, gamma/brightness correction, and NaN handling.\n */\nexport class ImageRenderer {\n    /**\n     * Render typed array to ImageData with normalization and corrections.\n     * @param {Uint8Array|Uint16Array|Float32Array|Float16Array} data - Image data\n     * @param {number} width - Image width\n     * @param {number} height - Image height\n     * @param {number} channels - Number of channels (1, 3, or 4)\n     * @param {boolean} isFloat - Whether data is floating point (float16 or float32)\n     * @param {{min: number, max: number}} stats - Image statistics\n     * @param {Object} settings - Normalization/gamma/brightness settings\n     * @param {Object} [options={}] - Additional options { nanColor }\n     * @returns {ImageData} Rendered image data\n     */\n    static render(data, width, height, channels, isFloat, stats, settings, options = {}) {\n        const perfStart = performance.now();\n        const result = this._renderInternal(data, width, height, channels, isFloat, stats, settings, options);\n\n        if (options.flipY) {\n            const flipped = this._flipY(result);\n            console.log(`[Render] Total render time: ${(performance.now() - perfStart).toFixed(2)}ms (with flip)`);\n            return flipped;\n        }\n        console.log(`[Render] Total render time: ${(performance.now() - perfStart).toFixed(2)}ms`);\n        return result;\n    }\n\n    static _renderInternal(data, width, height, channels, isFloat, stats, settings, options = {}) {\n        // Determine typeMax based on data type\n        let typeMax;\n        if (options.typeMax !== undefined) {\n            typeMax = options.typeMax;\n        } else if (isFloat) {\n            typeMax = 1.0;\n        } else if (data instanceof Uint16Array) {\n            typeMax = 65535;\n        } else {\n            typeMax = 255;\n        }\n\n        // Check mode first\n        const isGammaMode = settings.normalization?.gammaMode || false;\n\n        // Early optimization: In gamma mode with identity transform, skip stats calculation\n        // and use full type range directly (no need for actual data min/max)\n        const isIdentity = NormalizationHelper.isIdentityTransformation(settings);\n\n        let min, max;\n        if (isGammaMode && isIdentity) {\n            // Gamma mode + identity: use full type range, no stats needed\n            min = 0;\n            max = typeMax;\n        } else {\n            // Other modes: need to calculate proper normalization range from stats\n            const range = NormalizationHelper.getNormalizationRange(\n                settings, stats, typeMax, isFloat\n            );\n            min = range.min;\n            max = range.max;\n        }\n\n        if (isGammaMode) {\n            if (isIdentity) {\n                // Identity in gamma mode: just normalize, no LUT needed\n                if (isFloat) {\n                    return this._renderFloatDirect(data, width, height, channels, min, max, options);\n                } else if (data instanceof Uint16Array) {\n                    return this._renderUint16Direct(data, width, height, channels, min, max);\n                } else {\n                    return this._renderUint8Direct(data, width, height, channels, min, max);\n                }\n            } else {\n                // Non-identity in gamma mode: use LUT\n                if (isFloat) {\n                    return this._renderFloatWithLUT(data, width, height, channels, min, max, settings, options);\n                } else if (data instanceof Uint16Array) {\n                    return this._renderUint16WithLUT(data, width, height, channels, min, max, settings, options);\n                } else {\n                    return this._renderUint8WithLUT(data, width, height, channels, min, max, settings, options);\n                }\n            }\n        } else {\n            // Not in gamma mode: direct normalization only (no gamma/brightness, no LUT)\n            if (isFloat) {\n                return this._renderFloatDirect(data, width, height, channels, min, max, options);\n            } else if (data instanceof Uint16Array) {\n                return this._renderUint16Direct(data, width, height, channels, min, max, options);\n            } else {\n                return this._renderUint8Direct(data, width, height, channels, min, max, options);\n            }\n        }\n    }\n\n    /**\n     * Flip ImageData vertically\n     * @param {ImageData} imageData \n     * @returns {ImageData}\n     */\n    static _flipY(imageData) {\n        const width = imageData.width;\n        const height = imageData.height;\n        const data = imageData.data;\n        const lineSize = width * 4;\n        const tempLine = new Uint8ClampedArray(lineSize);\n\n        for (let y = 0; y < height / 2; y++) {\n            const topOffset = y * lineSize;\n            const bottomOffset = (height - 1 - y) * lineSize;\n\n            // Copy top line to temp\n            tempLine.set(data.subarray(topOffset, topOffset + lineSize));\n\n            // Copy bottom to top\n            data.copyWithin(topOffset, bottomOffset, bottomOffset + lineSize);\n\n            // Copy temp to bottom\n            data.set(tempLine, bottomOffset);\n        }\n        return imageData;\n    }\n\n\n    /**\n     * Render float32 data directly (no gamma/brightness, just normalization).\n     * Used in non-gamma mode or identity transform in gamma mode.\n     * @private\n     */\n    static _renderFloatDirect(data, width, height, channels, min, max, options) {\n        const out = new Uint8ClampedArray(width * height * 4);\n        const nanColor = options.nanColor || { r: 255, g: 0, b: 255 }; // Magenta default\n        const range = max - min;\n        const invRange = range > 0 ? 1.0 / range : 0;\n\n        for (let i = 0; i < width * height; i++) {\n            let r, g, b;\n\n            if (channels === 1) {\n                const value = data[i];\n                if (!Number.isFinite(value)) {\n                    r = g = b = nanColor.r;\n                } else {\n                    const normalized = (value - min) * invRange;\n                    const intensity = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n                    r = g = b = intensity;\n                }\n            } else if (channels === 3) {\n                const idx = i * 3;\n                const rVal = data[idx];\n                const gVal = data[idx + 1];\n                const bVal = data[idx + 2];\n\n                if (!Number.isFinite(rVal) || !Number.isFinite(gVal) || !Number.isFinite(bVal)) {\n                    r = nanColor.r;\n                    g = nanColor.g;\n                    b = nanColor.b;\n                } else {\n                    r = Math.round(Math.max(0, Math.min(1, (rVal - min) * invRange)) * 255);\n                    g = Math.round(Math.max(0, Math.min(1, (gVal - min) * invRange)) * 255);\n                    b = Math.round(Math.max(0, Math.min(1, (bVal - min) * invRange)) * 255);\n                }\n            } else if (channels === 4) {\n                const idx = i * 4;\n                const rVal = data[idx];\n                const gVal = data[idx + 1];\n                const bVal = data[idx + 2];\n                const aVal = data[idx + 3];\n\n                if (!Number.isFinite(rVal) || !Number.isFinite(gVal) || !Number.isFinite(bVal)) {\n                    r = nanColor.r;\n                    g = nanColor.g;\n                    b = nanColor.b;\n                } else {\n                    r = Math.round(Math.max(0, Math.min(1, (rVal - min) * invRange)) * 255);\n                    g = Math.round(Math.max(0, Math.min(1, (gVal - min) * invRange)) * 255);\n                    b = Math.round(Math.max(0, Math.min(1, (bVal - min) * invRange)) * 255);\n                }\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = Number.isFinite(aVal) ? Math.round(Math.max(0, Math.min(1, aVal)) * 255) : 255;\n                continue;\n            }\n\n            const p = i * 4;\n            out[p] = r;\n            out[p + 1] = g;\n            out[p + 2] = b;\n            out[p + 3] = 255;\n        }\n\n        return new ImageData(out, width, height);\n    }\n\n    /**\n     * Render float32 data with gamma/brightness using 16-bit LUT.\n     * Used in gamma mode with non-identity transform.\n     * @private\n     */\n    static _renderFloatWithLUT(data, width, height, channels, min, max, settings, options) {\n        const out = new Uint8ClampedArray(width * height * 4);\n        const nanColor = options.nanColor || { r: 255, g: 0, b: 255 };\n\n        // Generate 16-bit LUT for gamma/brightness\n        const { min: vMin, max: vMax } = NormalizationHelper.getEffectiveVisualizationRange(settings, min, max);\n        // For float, we map the quantized 0-65535 range to the LUT, not the float values directly\n        const lut = NormalizationHelper.generateLut(settings, 16, 65535, 0, 65535);\n        const vRange = vMax - vMin;\n        const invVRange = vRange > 0 ? 65535 / vRange : 0;\n\n        for (let i = 0; i < width * height; i++) {\n            let r, g, b;\n\n            if (channels === 1) {\n                const value = data[i];\n                if (!Number.isFinite(value)) {\n                    r = g = b = nanColor.r;\n                } else {\n                    const lutIdx = Math.round(Math.max(0, Math.min(65535, (value - vMin) * invVRange)));\n                    r = g = b = lut[lutIdx];\n                }\n            } else if (channels === 3) {\n                const idx = i * 3;\n                const rVal = data[idx];\n                const gVal = data[idx + 1];\n                const bVal = data[idx + 2];\n\n                if (!Number.isFinite(rVal) || !Number.isFinite(gVal) || !Number.isFinite(bVal)) {\n                    r = nanColor.r;\n                    g = nanColor.g;\n                    b = nanColor.b;\n                } else {\n                    const rIdx = Math.round(Math.max(0, Math.min(65535, (rVal - vMin) * invVRange)));\n                    const gIdx = Math.round(Math.max(0, Math.min(65535, (gVal - vMin) * invVRange)));\n                    const bIdx = Math.round(Math.max(0, Math.min(65535, (bVal - vMin) * invVRange)));\n                    r = lut[rIdx];\n                    g = lut[gIdx];\n                    b = lut[bIdx];\n                }\n            } else if (channels === 4) {\n                const idx = i * 4;\n                const rVal = data[idx];\n                const gVal = data[idx + 1];\n                const bVal = data[idx + 2];\n                const aVal = data[idx + 3];\n\n                if (!Number.isFinite(rVal) || !Number.isFinite(gVal) || !Number.isFinite(bVal)) {\n                    r = nanColor.r;\n                    g = nanColor.g;\n                    b = nanColor.b;\n                } else {\n                    const rIdx = Math.round(Math.max(0, Math.min(65535, (rVal - vMin) * invVRange)));\n                    const gIdx = Math.round(Math.max(0, Math.min(65535, (gVal - vMin) * invVRange)));\n                    const bIdx = Math.round(Math.max(0, Math.min(65535, (bVal - vMin) * invVRange)));\n                    r = lut[rIdx];\n                    g = lut[gIdx];\n                    b = lut[bIdx];\n                }\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = Number.isFinite(aVal) ? Math.round(Math.max(0, Math.min(1, aVal)) * 255) : 255;\n                continue;\n            }\n\n            const p = i * 4;\n            out[p] = r;\n            out[p + 1] = g;\n            out[p + 2] = b;\n            out[p + 3] = 255;\n        }\n\n        return new ImageData(out, width, height);\n    }\n\n    /**\n     * Render uint16 data directly (no gamma, just normalization).\n     * @private\n     */\n    static _renderUint16Direct(data, width, height, channels, min, max, options = {}) {\n        const out = new Uint8ClampedArray(width * height * 4);\n\n        if (options.rgbAs24BitGrayscale && channels >= 3) {\n            // Scale 16-bit down to 8-bit for 24-bit display\n            const range = max - min;\n            const invRange = range > 0 ? 1.0 / range : 0;\n\n            for (let i = 0; i < width * height; i++) {\n                const idx = i * channels;\n                // Scale 16-bit (0-65535) to 8-bit (0-255)\n                const r = Math.round(data[idx] / 257);\n                const g = Math.round(data[idx + 1] / 257);\n                const b = Math.round(data[idx + 2] / 257);\n                const val24 = (r << 16) | (g << 8) | b;\n\n                const normalized = (val24 - min) * invRange;\n                const val8 = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n\n                const p = i * 4;\n                out[p] = val8;\n                out[p + 1] = val8;\n                out[p + 2] = val8;\n                out[p + 3] = 255;\n            }\n            return new ImageData(out, width, height);\n        }\n        const range = max - min;\n        const invRange = range > 0 ? 255.0 / range : 0;\n\n        for (let i = 0; i < width * height; i++) {\n            let r, g, b;\n\n            if (channels === 1) {\n                const value = Math.max(min, Math.min(max, data[i]));\n                r = g = b = Math.round((value - min) * invRange);\n            } else if (channels === 3) {\n                const idx = i * 3;\n                r = Math.round((Math.max(min, Math.min(max, data[idx])) - min) * invRange);\n                g = Math.round((Math.max(min, Math.min(max, data[idx + 1])) - min) * invRange);\n                b = Math.round((Math.max(min, Math.min(max, data[idx + 2])) - min) * invRange);\n            } else if (channels === 4) {\n                const idx = i * 4;\n                r = Math.round((Math.max(min, Math.min(max, data[idx])) - min) * invRange);\n                g = Math.round((Math.max(min, Math.min(max, data[idx + 1])) - min) * invRange);\n                b = Math.round((Math.max(min, Math.min(max, data[idx + 2])) - min) * invRange);\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = Math.round(data[idx + 3] / 257); // 65535 -> 255\n                continue;\n            }\n\n            const p = i * 4;\n            out[p] = r;\n            out[p + 1] = g;\n            out[p + 2] = b;\n            out[p + 3] = 255;\n        }\n\n        return new ImageData(out, width, height);\n    }\n\n    /**\n     * Render uint16 data with gamma/brightness using LUT.\n     * @private\n     */\n    static _renderUint16WithLUT(data, width, height, channels, min, max, settings, options = {}) {\n        const out = new Uint8ClampedArray(width * height * 4);\n\n        if (options.rgbAs24BitGrayscale && channels >= 3) {\n            // Scale 16-bit down to 8-bit for 24-bit display\n            const range = max - min;\n            const invRange = range > 0 ? 1.0 / range : 0;\n\n            for (let i = 0; i < width * height; i++) {\n                const idx = i * channels;\n                // Scale 16-bit (0-65535) to 8-bit (0-255)\n                const r = Math.round(data[idx] / 257);\n                const g = Math.round(data[idx + 1] / 257);\n                const b = Math.round(data[idx + 2] / 257);\n                const val24 = (r << 16) | (g << 8) | b;\n\n                let normalized = (val24 - min) * invRange;\n                normalized = NormalizationHelper.applyGammaAndBrightness(normalized, settings);\n                const val8 = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n\n                const p = i * 4;\n                out[p] = val8;\n                out[p + 1] = val8;\n                out[p + 2] = val8;\n                out[p + 3] = 255;\n            }\n            return new ImageData(out, width, height);\n        }\n\n        // Generate 16-bit LUT\n        const normMin = Math.round(Math.max(0, Math.min(65535, min)));\n        const normMax = Math.round(Math.max(0, Math.min(65535, max)));\n        const lut = NormalizationHelper.generateLut(settings, 16, 65535, normMin, normMax);\n\n        for (let i = 0; i < width * height; i++) {\n            let r, g, b;\n\n            if (channels === 1) {\n                const value = Math.min(65535, data[i]);\n                r = g = b = lut[value];\n            } else if (channels === 3) {\n                const idx = i * 3;\n                r = lut[Math.min(65535, data[idx])];\n                g = lut[Math.min(65535, data[idx + 1])];\n                b = lut[Math.min(65535, data[idx + 2])];\n            } else if (channels === 4) {\n                const idx = i * 4;\n                r = lut[Math.min(65535, data[idx])];\n                g = lut[Math.min(65535, data[idx + 1])];\n                b = lut[Math.min(65535, data[idx + 2])];\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = Math.round(data[idx + 3] / 257); // 65535 -> 255\n                continue;\n            }\n\n            const p = i * 4;\n            out[p] = r;\n            out[p + 1] = g;\n            out[p + 2] = b;\n            out[p + 3] = 255;\n        }\n\n        return new ImageData(out, width, height);\n    }\n\n    /**\n     * Render uint8 data directly (no gamma, just normalization).\n     * @private\n     */\n    static _renderUint8Direct(data, width, height, channels, min, max, options = {}) {\n        const out = new Uint8ClampedArray(width * height * 4);\n\n        if (options.rgbAs24BitGrayscale && channels >= 3) {\n            const range = max - min;\n            const invRange = range > 0 ? 1.0 / range : 0;\n\n            for (let i = 0; i < width * height; i++) {\n                const idx = i * channels;\n                const r = data[idx];\n                const g = data[idx + 1];\n                const b = data[idx + 2];\n                const val24 = (r << 16) | (g << 8) | b;\n\n                const normalized = (val24 - min) * invRange;\n                const val8 = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n\n                const p = i * 4;\n                out[p] = val8;\n                out[p + 1] = val8;\n                out[p + 2] = val8;\n                out[p + 3] = 255;\n            }\n            return new ImageData(out, width, height);\n        }\n\n        if (min === 0 && max === 255) {\n            // Ultra-fast path: direct copy for full range\n            for (let i = 0; i < width * height; i++) {\n                const p = i * 4;\n                if (channels === 1) {\n                    const value = data[i];\n                    out[p] = out[p + 1] = out[p + 2] = value;\n                } else if (channels === 3) {\n                    const idx = i * 3;\n                    out[p] = data[idx];\n                    out[p + 1] = data[idx + 1];\n                    out[p + 2] = data[idx + 2];\n                } else if (channels === 4) {\n                    const idx = i * 4;\n                    out[p] = data[idx];\n                    out[p + 1] = data[idx + 1];\n                    out[p + 2] = data[idx + 2];\n                    out[p + 3] = data[idx + 3];\n                    continue;\n                }\n                out[p + 3] = 255;\n            }\n        } else {\n            // Normalize to custom range\n            const range = max - min;\n            const invRange = range > 0 ? 255.0 / range : 0;\n\n            for (let i = 0; i < width * height; i++) {\n                let r, g, b;\n\n                if (channels === 1) {\n                    const value = Math.max(min, Math.min(max, data[i]));\n                    r = g = b = Math.round((value - min) * invRange);\n                } else if (channels === 3) {\n                    const idx = i * 3;\n                    r = Math.round((Math.max(min, Math.min(max, data[idx])) - min) * invRange);\n                    g = Math.round((Math.max(min, Math.min(max, data[idx + 1])) - min) * invRange);\n                    b = Math.round((Math.max(min, Math.min(max, data[idx + 2])) - min) * invRange);\n                } else if (channels === 4) {\n                    const idx = i * 4;\n                    r = Math.round((Math.max(min, Math.min(max, data[idx])) - min) * invRange);\n                    g = Math.round((Math.max(min, Math.min(max, data[idx + 1])) - min) * invRange);\n                    b = Math.round((Math.max(min, Math.min(max, data[idx + 2])) - min) * invRange);\n\n                    const p = i * 4;\n                    out[p] = r;\n                    out[p + 1] = g;\n                    out[p + 2] = b;\n                    out[p + 3] = data[idx + 3];\n                    continue;\n                }\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = 255;\n            }\n        }\n\n        return new ImageData(out, width, height);\n    }\n\n    /**\n     * Render uint8 data with gamma/brightness using LUT.\n     * @private\n     */\n    static _renderUint8WithLUT(data, width, height, channels, min, max, settings, options = {}) {\n        const out = new Uint8ClampedArray(width * height * 4);\n\n        if (options.rgbAs24BitGrayscale && channels >= 3) {\n            const range = max - min;\n            const invRange = range > 0 ? 1.0 / range : 0;\n\n            for (let i = 0; i < width * height; i++) {\n                const idx = i * channels;\n                const r = data[idx];\n                const g = data[idx + 1];\n                const b = data[idx + 2];\n                const val24 = (r << 16) | (g << 8) | b;\n\n                let normalized = (val24 - min) * invRange;\n                normalized = NormalizationHelper.applyGammaAndBrightness(normalized, settings);\n                const val8 = Math.round(Math.max(0, Math.min(1, normalized)) * 255);\n\n                const p = i * 4;\n                out[p] = val8;\n                out[p + 1] = val8;\n                out[p + 2] = val8;\n                out[p + 3] = 255;\n            }\n            return new ImageData(out, width, height);\n        }\n\n        // Generate 8-bit LUT\n        const normMin = Math.round(Math.max(0, Math.min(255, min)));\n        const normMax = Math.round(Math.max(0, Math.min(255, max)));\n        const lut = NormalizationHelper.generateLut(settings, 8, 255, normMin, normMax);\n\n        for (let i = 0; i < width * height; i++) {\n            let r, g, b;\n\n            if (channels === 1) {\n                r = g = b = lut[data[i]];\n            } else if (channels === 3) {\n                const idx = i * 3;\n                r = lut[data[idx]];\n                g = lut[data[idx + 1]];\n                b = lut[data[idx + 2]];\n            } else if (channels === 4) {\n                const idx = i * 4;\n                r = lut[data[idx]];\n                g = lut[data[idx + 1]];\n                b = lut[data[idx + 2]];\n\n                const p = i * 4;\n                out[p] = r;\n                out[p + 1] = g;\n                out[p + 2] = b;\n                out[p + 3] = data[idx + 3];\n                continue;\n            }\n\n            const p = i * 4;\n            out[p] = r;\n            out[p + 1] = g;\n            out[p + 2] = b;\n            out[p + 3] = 255;\n        }\n\n        return new ImageData(out, width, height);\n    }\n}\n", "// @ts-check\n\"use strict\";\n\n/**\n * Fast TIFF Processor using WebAssembly\n * \n * This module provides a high-performance TIFF decoder using Rust/WebAssembly.\n * It can be used as a drop-in replacement for geotiff.js for faster loading.\n */\n\nlet wasmModule = null;\nlet wasmInitPromise = null;\n\n/**\n * Initialize the WASM module\n * @returns {Promise\\u003cany\\u003e}\n */\nasync function initWasm() {\n    if (wasmModule) {\n        return wasmModule;\n    }\n\n    if (wasmInitPromise) {\n        return wasmInitPromise;\n    }\n\n    wasmInitPromise = (async () => {\n        try {\n            // Import the JS bindings generated by wasm-pack\n            // Use relative path for VS Code webview compatibility\n            const { default: init, decode_tiff } = await import('../wasm/tiff-wasm.js');\n\n            // Initialize the WASM module\n            await init();\n\n            wasmModule = { decode_tiff };\n            return wasmModule;\n        } catch (error) {\n            console.warn('Failed to load WASM module, will use geotiff.js fallback:', error);\n            return null;\n        }\n    })();\n\n    return wasmInitPromise;\n}\n\n/**\n * @typedef {Object} TiffDecodeResult\n * @property {number} width\n * @property {number} height\n * @property {number} channels\n * @property {number} bitsPerSample\n * @property {number} sampleFormat - 1=uint, 2=int, 3=float\n * @property {number} compression - TIFF compression type\n * @property {number} predictor - TIFF predictor value\n * @property {number} photometricInterpretation - TIFF photometric interpretation\n * @property {number} planarConfiguration - TIFF planar configuration\n * @property {Float32Array} data - Pixel data as floats\n * @property {number} min - Minimum value\n * @property {number} max - Maximum value\n */\n\n/**\n * Fast TIFF Processor class using WASM\n */\nexport class TiffWasmProcessor {\n    constructor() {\n        /** @type {any} */\n        this.wasm = null;\n    }\n\n    /**\n     * Initialize the WASM module\n     * @returns {Promise\\u003cboolean\\u003e} - True if WASM loaded, false if falling back to JS\n     */\n    async init() {\n        this.wasm = await initWasm();\n        return this.wasm !== null;\n    }\n\n    /**\n     * Check if WASM is available\n     * @returns {boolean}\n     */\n    isAvailable() {\n        return this.wasm !== null;\n    }\n\n    /**\n     * Decode a TIFF file from an ArrayBuffer\n     * @param {ArrayBuffer} buffer - TIFF file data\n     * @returns {Promise\\u003cTiffDecodeResult\\u003e}\n     */\n    async decode(buffer) {\n        if (!this.wasm) {\n            throw new Error('WASM not initialized. Call init() first.');\n        }\n\n        const uint8Array = new Uint8Array(buffer);\n        const result = this.wasm.decode_tiff(uint8Array);\n\n        const decodeResult = {\n            width: result.width,\n            height: result.height,\n            channels: result.channels,\n            bitsPerSample: result.bits_per_sample,\n            sampleFormat: result.sample_format,\n            compression: result.compression,\n            predictor: result.predictor,\n            photometricInterpretation: result.photometric_interpretation,\n            planarConfiguration: result.planar_configuration,\n            data: new Float32Array(result.get_data_as_f32()),\n            min: result.min_value,\n            max: result.max_value\n        };\n\n        return decodeResult;\n    }\n}\n\n// Export for use\nexport { initWasm };\n", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\nimport { TiffWasmProcessor } from './tiff-wasm-wrapper.js';\n\n/**\n * @typedef {Object} GeoTIFFGlobal\n * @property {function} fromArrayBuffer\n */\n\n/**\n * @type {GeoTIFFGlobal}\n */\n// @ts-ignore - GeoTIFF is loaded globally via script tag\nconst GeoTIFF = window.GeoTIFF;\n\n/**\n * TIFF Processor Module\n * Handles TIFF image processing, normalization, and data extraction\n */\nexport class TiffProcessor {\n\tconstructor(settingsManager, vscode) {\n\t\tthis.settingsManager = settingsManager;\n\t\tthis.vscode = vscode;\n\t\tthis.rawTiffData = null;\n\t\tthis._pendingRenderData = null; // Store data waiting for format-specific settings\n\t\tthis._isInitialLoad = true; // Track if this is the first render\n\t\tthis._maskCache = new Map(); // Cache loaded mask images by URI\n\t\tthis._lastImageData = null; // Store the last rendered image data for fast parameter updates\n\t\tthis._lastStatistics = null; // Cache min/max statistics\n\t\t/** @type {{ floatData: Float32Array } | null} */\n\t\tthis._convertedFloatData = null; // Cache converted float data for analysis\n\n\t\t// WASM decoder\n\t\tthis._wasmProcessor = new TiffWasmProcessor();\n\t\tthis._wasmAvailable = false;\n\t\tthis._wasmProcessor.init().then(available => {\n\t\t\tthis._wasmAvailable = available;\n\t\t\tif (available) {\n\t\t\t\tconsole.log('[TiffProcessor] WASM decoder initialized successfully');\n\t\t\t} else {\n\t\t\t\tconsole.log('[TiffProcessor] Using geotiff.js fallback');\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.warn('[TiffProcessor] WASM initialization failed:', err);\n\t\t\tthis._wasmAvailable = false;\n\t\t});\n\t}\n\n\t/**\n\t * Clamp a value between min and max\n\t * @param {number} value\n\t * @param {number} min\n\t * @param {number} max\n\t * @returns {number}\n\t */\n\tclamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n\n\t/**\n\t * Get NaN color based on settings\n\t * @param {Object} settings - Current settings\n\t * @returns {Object} - RGB values for NaN color\n\t */\n\t/**\n\t * Get NaN color from settings\n\t * @param {any} settings - Settings object\n\t * @returns {{r: number, g: number, b: number}}\n\t */\n\t_getNanColor(settings) {\n\t\tif (settings.nanColor === 'fuchsia') {\n\t\t\treturn { r: 255, g: 0, b: 255 }; // Fuchsia\n\t\t} else {\n\t\t\treturn { r: 0, g: 0, b: 0 }; // Black (default)\n\t\t}\n\t}\n\n\t/**\n\t * Process TIFF file from URL\n\t * @param {string} src - TIFF file URL\n\t * @returns {Promise<{canvas: HTMLCanvasElement, imageData: ImageData, tiffData: Object}>}\n\t */\n\tasync processTiff(src) {\n\t\tconst startTime = performance.now();\n\t\ttry {\n\t\t\tconst response = await fetch(src);\n\t\t\tconst buffer = await response.arrayBuffer();\n\t\t\tconst fetchTime = performance.now() - startTime;\n\t\t\tconsole.log(`[TiffProcessor] Fetch time: ${fetchTime.toFixed(2)}ms`);\n\n\t\t\t// Wait for WASM initialization if it's in progress\n\t\t\tif (!this._wasmAvailable && this._wasmProcessor) {\n\t\t\t\tawait this._wasmProcessor.init();\n\t\t\t\tthis._wasmAvailable = this._wasmProcessor.isAvailable();\n\t\t\t}\n\n\t\t\t// Check if we should use WASM decoder\n\t\t\tconst settings = this.settingsManager.settings;\n\t\t\tconst use24BitMode = settings.rgbAs24BitGrayscale || false;\n\n\t\t\tlet useWasm = this._wasmAvailable && !use24BitMode;\n\t\t\tconsole.log(`[TiffProcessor] Decode decision: wasmAvailable=${this._wasmAvailable}, 24BitMode=${use24BitMode}, willUseWasm=${useWasm}`);\n\n\t\t\t// Try WASM decoding first if available\n\t\t\tif (useWasm) {\n\t\t\t\ttry {\n\t\t\t\t\tconst decodeStart = performance.now();\n\t\t\t\t\tconst wasmResult = await this._wasmProcessor.decode(buffer);\n\t\t\t\t\tconst decodeTime = performance.now() - decodeStart;\n\t\t\t\t\tconsole.log(`[TiffProcessor] WASM decode time: ${decodeTime.toFixed(2)}ms`);\n\n\t\t\t\t\t// Convert WASM result to format compatible with existing code\n\t\t\t\t\tconst width = wasmResult.width;\n\t\t\t\t\tconst height = wasmResult.height;\n\t\t\t\t\tconst samplesPerPixel = wasmResult.channels;\n\t\t\t\t\tconst bitsPerSample = wasmResult.bitsPerSample;\n\t\t\t\t\tconst sampleFormat = wasmResult.sampleFormat;\n\n\t\t\t\t\t// Create rasters from WASM data (deinterleave if needed)\n\t\t\t\t\tconst rasters = [];\n\t\t\t\t\tif (samplesPerPixel === 1) {\n\t\t\t\t\t\trasters.push(wasmResult.data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Deinterleave for compatibility with existing rendering code\n\t\t\t\t\t\tfor (let c = 0; c < samplesPerPixel; c++) {\n\t\t\t\t\t\t\tconst channel = new Float32Array(width * height);\n\t\t\t\t\t\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\t\t\t\t\t\tchannel[i] = wasmResult.data[i * samplesPerPixel + c];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trasters.push(channel);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store interleaved data\n\t\t\t\t\tconst data = wasmResult.data;\n\n\t\t\t\t\t// Use metadata from WASM (no need to parse again with geotiff.js!)\n\t\t\t\t\tconst compression = wasmResult.compression;\n\t\t\t\t\tconst predictor = wasmResult.predictor;\n\t\t\t\t\tconst photometricInterpretation = wasmResult.photometricInterpretation;\n\t\t\t\t\tconst planarConfig = wasmResult.planarConfiguration;\n\t\t\t\t\tconsole.log(`[TiffProcessor] Using metadata from WASM: compression=${compression}, predictor=${predictor}`);\n\n\t\t\t\t\t// Store TIFF data for pixel inspection and re-rendering\n\t\t\t\t\t// Create a minimal image-like object for compatibility\n\t\t\t\t\tconst image = {\n\t\t\t\t\t\tgetWidth: () => width,\n\t\t\t\t\t\tgetHeight: () => height,\n\t\t\t\t\t\tgetSamplesPerPixel: () => samplesPerPixel,\n\t\t\t\t\t\tgetBitsPerSample: () => bitsPerSample,\n\t\t\t\t\t\tgetSampleFormat: () => sampleFormat\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.rawTiffData = {\n\t\t\t\t\t\timage: image,\n\t\t\t\t\t\trasters: rasters,\n\t\t\t\t\t\tifd: {\n\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\tt339: sampleFormat,\n\t\t\t\t\t\t\tt277: samplesPerPixel,\n\t\t\t\t\t\t\tt284: 1, // Planar config (chunky)\n\t\t\t\t\t\t\tt258: bitsPerSample\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: data\n\t\t\t\t\t};\n\n\t\t\t\t\t// Send format information to VS Code\n\t\t\t\t\tif (this.vscode && this._isInitialLoad) {\n\t\t\t\t\t\tconst showNormTiff = sampleFormat === 3;\n\t\t\t\t\t\tconst formatType = showNormTiff ? 'tiff-float' : 'tiff-int';\n\n\t\t\t\t\t\tthis.vscode.postMessage({\n\t\t\t\t\t\t\ttype: 'formatInfo',\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\tsampleFormat,\n\t\t\t\t\t\t\t\tcompression,\n\t\t\t\t\t\t\t\tpredictor,\n\t\t\t\t\t\t\t\tphotometricInterpretation,\n\t\t\t\t\t\t\t\tplanarConfig,\n\t\t\t\t\t\t\t\tsamplesPerPixel,\n\t\t\t\t\t\t\t\tbitsPerSample,\n\t\t\t\t\t\t\t\tformatType,\n\t\t\t\t\t\t\t\tisInitialLoad: true,\n\t\t\t\t\t\t\t\tdecodedWith: 'wasm'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis._pendingRenderData = { image, rasters };\n\n\t\t\t\t\t\tconst canvas = document.createElement('canvas');\n\t\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\t\tconst placeholderImageData = new ImageData(width, height);\n\t\t\t\t\t\treturn { canvas, imageData: placeholderImageData, tiffData: this.rawTiffData };\n\t\t\t\t\t}\n\n\t\t\t\t\tconst canvas = document.createElement('canvas');\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\tconst imageData = await this.renderTiff(image, rasters);\n\t\t\t\t\tconst totalTime = performance.now() - startTime;\n\t\t\t\t\tconsole.log(`[TiffProcessor] Total WASM processing time: ${totalTime.toFixed(2)}ms`);\n\t\t\t\t\treturn { canvas, imageData, tiffData: this.rawTiffData };\n\t\t\t\t} catch (wasmError) {\n\t\t\t\t\tconsole.warn('[TiffProcessor] WASM decoding failed, falling back to geotiff.js:', wasmError);\n\t\t\t\t\t// Fall through to geotiff.js implementation below\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback to geotiff.js (or if WASM not available/failed)\n\t\t\tconst decodeStart = performance.now();\n\t\t\tconst tiff = await GeoTIFF.fromArrayBuffer(buffer);\n\t\t\tconst image = await tiff.getImage();\n\t\t\tconst sampleFormat = image.getSampleFormat();\n\n\t\t\t// Post format info to VS Code\n\t\t\tconst width = image.getWidth();\n\t\t\tconst height = image.getHeight();\n\n\t\t\tconst fileDir = image.fileDirectory || {};\n\t\t\tconst compression = fileDir.Compression || 'Unknown';\n\t\t\tconst predictor = fileDir.Predictor;\n\t\t\tconst photometricInterpretation = fileDir.PhotometricInterpretation;\n\t\t\tconst planarConfig = fileDir.PlanarConfiguration;\n\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst rasters = await image.readRasters();\n\t\t\tconst decodeTime = performance.now() - decodeStart;\n\t\t\tconsole.log(`[TiffProcessor] geotiff.js decode time: ${decodeTime.toFixed(2)}ms`);\n\n\t\t\tconst samplesPerPixel = image.getSamplesPerPixel();\n\t\t\tconst bitsPerSample = image.getBitsPerSample();\n\n\t\t\t// Choose the correct typed array based on sample format and bits per sample\n\t\t\tlet data;\n\t\t\tconst showNormFormat = Array.isArray(sampleFormat) ? sampleFormat.includes(3) : sampleFormat === 3;\n\t\t\tif (showNormFormat) {\n\t\t\t\tdata = new Float32Array(width * height * samplesPerPixel);\n\t\t\t} else if (bitsPerSample === 16) {\n\t\t\t\tdata = new Uint16Array(width * height * samplesPerPixel);\n\t\t\t} else {\n\t\t\t\tdata = new Uint8Array(width * height * samplesPerPixel);\n\t\t\t}\n\n\t\t\t// Store data properly based on samples per pixel\n\t\t\tif (samplesPerPixel === 1) {\n\t\t\t\tdata.set(rasters[0]);\n\t\t\t} else {\n\t\t\t\t// Interleave the data: RGBRGBRGB...\n\t\t\t\tfor (let i = 0; i < rasters[0].length; i++) {\n\t\t\t\t\tfor (let j = 0; j < samplesPerPixel; j++) {\n\t\t\t\t\t\tdata[i * samplesPerPixel + j] = rasters[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store TIFF data for pixel inspection and re-rendering\n\t\t\tthis.rawTiffData = {\n\t\t\t\timage: image,\n\t\t\t\trasters: rasters,\n\t\t\t\tifd: {\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tt339: Array.isArray(sampleFormat) ? sampleFormat[0] : sampleFormat, // SampleFormat\n\t\t\t\t\tt277: samplesPerPixel, // SamplesPerPixel\n\t\t\t\t\tt284: 1, // PlanarConfiguration (chunky)\n\t\t\t\t\tt258: bitsPerSample // BitsPerSample\n\t\t\t\t},\n\t\t\t\tdata: data\n\t\t\t};\n\n\t\t\t// Send format information to VS Code BEFORE rendering\n\t\t\t// This allows the extension to apply format-specific settings first\n\t\t\tif (this.vscode && this._isInitialLoad) {\n\t\t\t\t// Determine if this is a float TIFF or int TIFF\n\t\t\t\tconst showNormTiff = sampleFormat === 3; // 3 = IEEE floating point\n\t\t\t\tconst formatType = showNormTiff ? 'tiff-float' : 'tiff-int';\n\n\t\t\t\tthis.vscode.postMessage({\n\t\t\t\t\ttype: 'formatInfo',\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\tsampleFormat: sampleFormat,\n\t\t\t\t\t\tcompression: compression,\n\t\t\t\t\t\tpredictor: predictor,\n\t\t\t\t\t\tphotometricInterpretation: photometricInterpretation,\n\t\t\t\t\t\tplanarConfig: planarConfig,\n\t\t\t\t\t\tsamplesPerPixel: image.getSamplesPerPixel(),\n\t\t\t\t\t\tbitsPerSample: image.getBitsPerSample(),\n\t\t\t\t\t\tformatType: formatType, // For per-format settings\n\t\t\t\t\t\tisInitialLoad: true, // Signal that this is the first load\n\t\t\t\t\t\tdecodedWith: use24BitMode ? 'geotiff.js (24-bit mode)' : 'geotiff.js'\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Store pending render data - will render when settings are updated\n\t\t\t\tthis._pendingRenderData = { image, rasters };\n\n\t\t\t\t// Return placeholder - actual rendering happens when settings update\n\t\t\t\tconst placeholderImageData = new ImageData(width, height);\n\t\t\t\treturn { canvas, imageData: placeholderImageData, tiffData: this.rawTiffData };\n\t\t\t}\n\n\t\t\t// Non-initial loads or if no vscode (render immediately)\n\t\t\tconst imageData = await this.renderTiff(image, rasters);\n\t\t\tconst totalTime = performance.now() - startTime;\n\t\t\tconsole.log(`[TiffProcessor] Total geotiff.js processing time: ${totalTime.toFixed(2)}ms`);\n\t\t\treturn { canvas, imageData, tiffData: this.rawTiffData };\n\t\t} catch (error) {\n\t\t\tconsole.error('Error processing TIFF:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Render TIFF data to ImageData with current settings\n\t * @param {*} image - GeoTIFF image object\n\t * @param {*} rasters - Raster data\n\t * @returns {Promise<ImageData>}\n\t */\n\tasync renderTiffWithSettings(image, rasters) {\n\t\t// Create copies of rasters to avoid modifying the original data\n\t\tconst rastersCopy = [];\n\t\tfor (let i = 0; i < rasters.length; i++) {\n\t\t\trastersCopy.push(new Float32Array(rasters[i]));\n\t\t}\n\n\t\t// Apply mask filtering if enabled\n\t\tconst settings = this.settingsManager.settings;\n\t\tif (settings.maskFilters && settings.maskFilters.length > 0) {\n\t\t\ttry {\n\t\t\t\t// Apply all enabled masks in sequence\n\t\t\t\tfor (const maskFilter of settings.maskFilters) {\n\t\t\t\t\tif (maskFilter.enabled && maskFilter.maskUri) {\n\t\t\t\t\t\tconst maskData = await this.loadMaskImage(maskFilter.maskUri);\n\t\t\t\t\t\t// Apply mask filter to each band\n\t\t\t\t\t\tfor (let band = 0; band < rastersCopy.length; band++) {\n\t\t\t\t\t\t\tconst filteredData = this.applyMaskFilter(\n\t\t\t\t\t\t\t\trastersCopy[band],\n\t\t\t\t\t\t\t\tmaskData,\n\t\t\t\t\t\t\t\tmaskFilter.threshold,\n\t\t\t\t\t\t\t\tmaskFilter.filterHigher\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\trastersCopy[band] = filteredData;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error applying mask filters:', error);\n\t\t\t\t// Continue without mask filtering if there's an error\n\t\t\t}\n\t\t}\n\n\t\tconst width = image.getWidth();\n\t\tconst height = image.getHeight();\n\t\tconst sampleFormat = image.getSampleFormat();\n\t\tconst bitsPerSample = image.getBitsPerSample();\n\t\tconst channels = rastersCopy.length;\n\n\t\tconst showNorm = Array.isArray(sampleFormat) ? sampleFormat.includes(3) : sampleFormat === 3;\n\t\tconst isFloat = showNorm;\n\n\t\t// Calculate stats if needed (for auto-normalize or just to have them)\n\t\tlet stats = this._lastStatistics;\n\t\tconst isGammaMode = settings.normalization?.gammaMode || false;\n\n\t\tif (!stats && !isGammaMode) {\n\t\t\tif (isFloat) {\n\t\t\t\t// Use centralized float stats calculator\n\t\t\t\t// We need to interleave data for the calculator if it's planar\n\t\t\t\t// But ImageStatsCalculator expects interleaved data or we can pass rasters?\n\t\t\t\t// ImageStatsCalculator expects a single data array (interleaved).\n\t\t\t\t// TIFF rasters are separate arrays (planar).\n\t\t\t\t// We need to combine them or update ImageStatsCalculator to handle planar.\n\t\t\t\t// Actually, let's just use the existing logic for now but simplified, OR\n\t\t\t\t// create a temporary interleaved buffer? That's expensive.\n\t\t\t\t// Better: Use a helper that handles planar data or just loop here.\n\n\t\t\t\t// Wait, ImageStatsCalculator.calculateFloatStats takes (data, width, height, channels).\n\t\t\t\t// If data is planar (array of arrays), it won't work.\n\t\t\t\t// Let's check ImageStatsCalculator implementation.\n\n\t\t\t\t// It assumes interleaved.\n\t\t\t\t// For TIFF, we might want to keep the local stats calculation for now to avoid copying data,\n\t\t\t\t// OR update ImageStatsCalculator to support planar data.\n\t\t\t\t// Given the performance focus, let's keep local stats calculation for TIFF planar data\n\t\t\t\t// but use the same logic structure.\n\n\t\t\t\tlet min = Infinity;\n\t\t\t\tlet max = -Infinity;\n\n\t\t\t\t// Use the first 3 channels to determine the image stats\n\t\t\t\tif (settings.rgbAs24BitGrayscale && rastersCopy.length >= 3) {\n\t\t\t\t\t// Calculate min/max of combined 24-bit values\n\t\t\t\t\tfor (let j = 0; j < rastersCopy[0].length; j++) {\n\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\t\t\t\tconst value = rastersCopy[i][j];\n\t\t\t\t\t\t\tif (!isNaN(value) && isFinite(value)) {\n\t\t\t\t\t\t\t\tvalues.push(Math.round(Math.max(0, Math.min(255, value))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalues.push(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst combined24bit = (values[0] << 16) | (values[1] << 8) | values[2];\n\t\t\t\t\t\tmin = Math.min(min, combined24bit);\n\t\t\t\t\t\tmax = Math.max(max, combined24bit);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Normal mode: use individual channel values\n\t\t\t\t\tfor (let i = 0; i < Math.min(rastersCopy.length, 3); i++) {\n\t\t\t\t\t\tfor (let j = 0; j < rastersCopy[i].length; j++) {\n\t\t\t\t\t\t\tconst value = rastersCopy[i][j];\n\t\t\t\t\t\t\tif (!isNaN(value) && isFinite(value)) {\n\t\t\t\t\t\t\t\tmin = Math.min(min, value);\n\t\t\t\t\t\t\t\tmax = Math.max(max, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstats = { min, max };\n\t\t\t} else {\n\t\t\t\t// Integer stats\n\t\t\t\t// Similar logic for integer\n\t\t\t\tlet min = Infinity;\n\t\t\t\tlet max = -Infinity;\n\n\t\t\t\tif (settings.rgbAs24BitGrayscale && rastersCopy.length >= 3) {\n\t\t\t\t\t// Same 24-bit logic\n\t\t\t\t\tfor (let j = 0; j < rastersCopy[0].length; j++) {\n\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\t\t\t\tconst value = rastersCopy[i][j];\n\t\t\t\t\t\t\tvalues.push(Math.round(Math.max(0, Math.min(255, value))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst combined24bit = (values[0] << 16) | (values[1] << 8) | values[2];\n\t\t\t\t\t\tmin = Math.min(min, combined24bit);\n\t\t\t\t\t\tmax = Math.max(max, combined24bit);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < Math.min(rastersCopy.length, 3); i++) {\n\t\t\t\t\t\tfor (let j = 0; j < rastersCopy[i].length; j++) {\n\t\t\t\t\t\t\tconst value = rastersCopy[i][j];\n\t\t\t\t\t\t\tmin = Math.min(min, value);\n\t\t\t\t\t\t\tmax = Math.max(max, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstats = { min, max };\n\t\t\t}\n\n\t\t\tthis._lastStatistics = stats;\n\t\t}\n\n\t\t// Send stats to VS Code\n\t\tif (this.vscode && stats) {\n\t\t\tthis.vscode.postMessage({ type: 'stats', value: stats });\n\t\t}\n\n\t\tconst nanColor = this._getNanColor(settings);\n\n\t\t// Prepare data for ImageRenderer\n\t\t// ImageRenderer expects interleaved data. TIFF rasters are planar.\n\t\t// We MUST interleave the data before passing to ImageRenderer.\n\t\t// This is a necessary step for centralization.\n\n\t\tlet interleavedData;\n\t\tconst len = width * height;\n\n\t\tif (isFloat) {\n\t\t\tinterleavedData = new Float32Array(len * channels);\n\t\t} else if (bitsPerSample === 16) {\n\t\t\tinterleavedData = new Uint16Array(len * channels);\n\t\t} else {\n\t\t\tinterleavedData = new Uint8Array(len * channels);\n\t\t}\n\n\t\t// Interleave\n\t\tif (channels === 1) {\n\t\t\tinterleavedData.set(rastersCopy[0]);\n\t\t} else {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tfor (let c = 0; c < channels; c++) {\n\t\t\t\t\tinterleavedData[i * channels + c] = rastersCopy[c][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create options object\n\t\tconst options = {\n\t\t\tnanColor: nanColor,\n\t\t\trgbAs24BitGrayscale: settings.rgbAs24BitGrayscale\n\t\t};\n\n\t\treturn ImageRenderer.render(\n\t\t\tinterleavedData,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tchannels,\n\t\t\tisFloat,\n\t\t\tstats || { min: 0, max: 1 },\n\t\t\tsettings,\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Fast render TIFF data with current settings (skips mask loading and uses cached statistics)\n\t * @param {*} image - GeoTIFF image object\n\t * @param {*} rasters - Raster data\n\t * @param {boolean} skipMasks - Whether to skip mask filtering\n\t * @returns {Promise<ImageData>}\n\t */\n\tasync renderTiffWithSettingsFast(image, rasters, skipMasks = true) {\n\t\t// Redirect to main render method for now to ensure correctness and use centralized ImageRenderer\n\t\t// TODO: Re-implement optimization for skipMasks if needed\n\t\treturn this.renderTiffWithSettings(image, rasters);\n\t}\n\n\tasync renderTiff(image, rasters) {\n\t\treturn this.renderTiffWithSettings(image, rasters);\n\t}\n\n\t/**\n\t * Load mask image for filtering\n\t * @param {string} maskSrc - Mask TIFF file URL\n\t * @returns {Promise<Float32Array>}\n\t */\n\tasync loadMaskImage(maskSrc) {\n\t\t// Check cache first\n\t\tif (this._maskCache.has(maskSrc)) {\n\t\t\treturn this._maskCache.get(maskSrc);\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await fetch(maskSrc);\n\t\t\tconst buffer = await response.arrayBuffer();\n\t\t\tconst tiff = await GeoTIFF.fromArrayBuffer(buffer);\n\t\t\tconst image = await tiff.getImage();\n\t\t\tconst rasters = await image.readRasters();\n\n\t\t\t// Return the first band as a Float32Array\n\t\t\tconst maskData = new Float32Array(rasters[0]);\n\n\t\t\t// Cache the mask data\n\t\t\tthis._maskCache.set(maskSrc, maskData);\n\n\t\t\treturn maskData;\n\t\t} catch (error) {\n\t\t\tconsole.error('Error loading mask image:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Clear the mask cache (call when mask URIs change)\n\t */\n\tclearMaskCache() {\n\t\tthis._maskCache.clear();\n\t}\n\n\t/**\n\t * Apply mask filtering to image data\n\t * @param {Float32Array} imageData - Original image data\n\t * @param {Float32Array} maskData - Mask data\n\t * @param {number} threshold - Threshold value\n\t * @param {boolean} filterHigher - Whether to filter higher or lower values\n\t * @returns {Float32Array} - Filtered image data\n\t */\n\tapplyMaskFilter(imageData, maskData, threshold, filterHigher) {\n\t\tconst filteredData = new Float32Array(imageData.length);\n\n\t\tfor (let i = 0; i < imageData.length; i++) {\n\t\t\tconst maskValue = maskData[i];\n\t\t\tconst imageValue = imageData[i];\n\n\t\t\tlet shouldFilter = false;\n\t\t\tif (filterHigher) {\n\t\t\t\tshouldFilter = maskValue > threshold;\n\t\t\t} else {\n\t\t\t\tshouldFilter = maskValue < threshold;\n\t\t\t}\n\n\t\t\tif (shouldFilter) {\n\t\t\t\tfilteredData[i] = NaN;\n\t\t\t} else {\n\t\t\t\tfilteredData[i] = imageValue;\n\t\t\t}\n\t\t}\n\n\t\treturn filteredData;\n\t}\n\n\t/**\n\t * Get color at specific pixel coordinates\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} naturalWidth\n\t * @param {number} naturalHeight\n\t * @returns {string}\n\t */\n\tgetColorAtPixel(x, y, naturalWidth, naturalHeight) {\n\t\t// Check for converted colormap data first\n\t\tif (this._convertedFloatData) {\n\t\t\tconst pixelIndex = y * naturalWidth + x;\n\t\t\tconst floatValue = this._convertedFloatData.floatData[pixelIndex];\n\t\t\treturn floatValue.toPrecision(6);\n\t\t}\n\n\t\tif (!this.rawTiffData) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst ifd = this.rawTiffData.ifd;\n\t\tconst data = this.rawTiffData.data;\n\t\tconst pixelIndex = y * naturalWidth + x;\n\t\tconst format = ifd.t339; // SampleFormat\n\t\tconst samples = ifd.t277;\n\t\tconst planarConfig = ifd.t284;\n\t\tconst bitsPerSample = ifd.t258;\n\t\tconst settings = this.settingsManager.settings;\n\n\t\tif (samples === 1) { // Grayscale\n\t\t\tconst value = data[pixelIndex];\n\n\t\t\t// Check if normalized float mode is enabled for uint images\n\t\t\tif (settings.normalizedFloatMode && format !== 3) {\n\t\t\t\t// Convert uint to normalized float (0-1)\n\t\t\t\tconst maxValue = bitsPerSample === 16 ? 65535 : 255;\n\t\t\t\tconst normalized = value / maxValue;\n\t\t\t\treturn normalized.toPrecision(4);\n\t\t\t}\n\n\t\t\treturn format === 3 ? value.toPrecision(4) : value.toString();\n\t\t} else if (samples >= 3) {\n\t\t\tconst values = [];\n\t\t\tif (planarConfig === 2) { // Planar data\n\t\t\t\tconst planeSize = naturalWidth * naturalHeight;\n\t\t\t\tfor (let i = 0; i < samples; i++) {\n\t\t\t\t\tconst value = data[pixelIndex + i * planeSize];\n\t\t\t\t\tvalues.push(format === 3 ? value.toPrecision(4) : value.toString().padStart(3, '0'));\n\t\t\t\t}\n\t\t\t} else { // Interleaved data\n\t\t\t\tfor (let i = 0; i < samples; i++) {\n\t\t\t\t\tconst value = data[pixelIndex * samples + i];\n\t\t\t\t\tvalues.push(format === 3 ? value.toPrecision(4) : value.toString().padStart(3, '0'));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If RGB as 24-bit grayscale is enabled, show combined value\n\t\t\tif (settings.rgbAs24BitGrayscale && samples >= 3) {\n\t\t\t\t// Convert string values back to numbers for calculation\n\t\t\t\tconst r = parseInt(values[0]);\n\t\t\t\tconst g = parseInt(values[1]);\n\t\t\t\tconst b = parseInt(values[2]);\n\t\t\t\t// Combine into 24-bit value: (R << 16) | (G << 8) | B\n\t\t\t\tconst combined24bit = (r << 16) | (g << 8) | b;\n\n\t\t\t\t// Apply scale factor for display\n\t\t\t\tconst scaleFactor = settings.scale24BitFactor || 1000;\n\t\t\t\tconst scaledValue = (combined24bit / scaleFactor).toFixed(3);\n\n\t\t\t\treturn scaledValue;\n\t\t\t}\n\n\t\t\tif (format === 3) {\n\t\t\t\treturn values.join(' ');\n\t\t\t} else {\n\t\t\t\treturn values.slice(0, 3).join(' ');\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Fast parameter update - DISABLED to prevent double-correction\n\t * We always re-render from raw TIFF data to ensure correct gamma/brightness application\n\t * @param {ImageData} existingImageData - Current image data\n\t * @returns {Promise<ImageData|null>} - Always returns null to force full re-render\n\t */\n\tasync fastParameterUpdate(existingImageData) {\n\t\t// Fast update is disabled because it causes double-application of corrections\n\t\t// and produces incorrect results (white/black flash, wrong colors).\n\t\t// Always return null to force a full re-render from raw TIFF data.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Perform the initial render if it was deferred\n\t * Called when format-specific settings have been applied\n\t * @returns {Promise<ImageData|null>} - The rendered image data, or null if no pending render\n\t */\n\tasync performDeferredRender() {\n\t\tconst perfStart = performance.now();\n\t\tif (!this._pendingRenderData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { image, rasters } = this._pendingRenderData;\n\t\tthis._pendingRenderData = null;\n\t\tthis._isInitialLoad = false;\n\n\t\t// Now render with the correct format-specific settings\n\t\tconst imageData = await this.renderTiff(image, rasters);\n\t\tconsole.log(`[TiffProcessor] Deferred render took ${(performance.now() - perfStart).toFixed(2)}ms`);\n\t\treturn imageData;\n\t}\n} ", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\n\n/**\n * @typedef {Object} ExrImageData\n * @property {number} width\n * @property {number} height\n * @property {Float32Array | Uint16Array} data\n * @property {number} channels - 1 (grayscale), 3 (RGB), or 4 (RGBA)\n * @property {number} type - Float type (1015 = Float32, 1016 = Float16)\n * @property {number} format - Color format (1023 = RGBA, 1028 = Red/Grayscale)\n */\n\n/**\n * EXR Processor Module\n * Handles OpenEXR image processing, normalization, and HDR tone mapping\n * Uses parse-exr library for EXR file parsing\n */\nexport class ExrProcessor {\n\tconstructor(settingsManager, vscode) {\n\t\tthis.settingsManager = settingsManager;\n\t\tthis.vscode = vscode;\n\t\tthis._lastRaw = null; // { width, height, data: Float32Array }\n\t\tthis._pendingRenderData = null; // Store data waiting for format-specific settings\n\t\tthis._isInitialLoad = true; // Track if this is the first render\n\t\tthis._cachedStats = undefined; // Cache for min/max stats (only used in stats mode)\n\t}\n\n\t/**\n\t * Clamp a value between min and max\n\t * @param {number} value\n\t * @param {number} min\n\t * @param {number} max\n\t * @returns {number}\n\t */\n\tclamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n\n\t/**\n\t * Get NaN color based on settings\n\t * @param {Object} settings - Current settings\n\t * @returns {Object} - RGB values for NaN color\n\t */\n\t_getNanColor(settings) {\n\t\tif (settings.nanColor === 'fuchsia') {\n\t\t\treturn { r: 255, g: 0, b: 255 }; // Fuchsia\n\t\t} else {\n\t\t\treturn { r: 0, g: 0, b: 0 }; // Black (default)\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Process EXR file from URL\n\t * @param {string} src - EXR file URL\n\t * @returns {Promise<{canvas: HTMLCanvasElement, imageData: ImageData, exrData: Object}>}\n\t */\n\tasync processExr(src) {\n\t\ttry {\n\t\t\t// Check if parseExr is available (from parse-exr library)\n\t\t\t// @ts-ignore\n\t\t\tif (typeof parseExr === 'undefined') {\n\t\t\t\tthrow new Error('parseExr library not loaded. Make sure parse-exr is included.');\n\t\t\t}\n\n\t\t\tconst response = await fetch(src);\n\t\t\tconst buffer = await response.arrayBuffer();\n\n\t\t\t// Invalidate stats cache for new image\n\t\t\tthis._cachedStats = undefined;\n\n\t\t\t// Parse EXR using parse-exr library\n\t\t\t// Use FloatType (1015) to get Float32Array with decoded float values\n\t\t\t// HalfFloatType (1016) returns Uint16Array with raw bytes which need decoding\n\t\t\t// @ts-ignore\n\t\t\tconst FloatType = 1015;\n\t\t\t// @ts-ignore\n\t\t\tconst exrResult = parseExr(buffer, FloatType);\n\n\t\t\tconst { width, height, data, format, type } = exrResult;\n\n\t\t\t// Determine channels based on format\n\t\t\t// RGBAFormat = 1023, RedFormat = 1028\n\t\t\tlet channels;\n\t\t\tif (format === 1023) { // RGBA\n\t\t\t\tchannels = 4;\n\t\t\t} else if (format === 1028) { // Red (grayscale)\n\t\t\t\tchannels = 1;\n\t\t\t} else {\n\t\t\t\t// Fallback: try to detect from data length\n\t\t\t\tconst pixelCount = width * height;\n\t\t\t\tconst totalValues = data.length;\n\t\t\t\tchannels = totalValues / pixelCount;\n\t\t\t}\n\n\t\t\t// Create canvas\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\t// Store raw EXR data for pixel inspection and re-rendering\n\t\t\tthis.rawExrData = {\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdata: data, // Float32Array or Uint16Array\n\t\t\t\tchannels,\n\t\t\t\ttype, // 1015 = Float32, 1016 = HalfFloat\n\t\t\t\tformat,\n\t\t\t\tisFloat: true // EXR is always floating point\n\t\t\t};\n\n\t\t\t// Send format information to VS Code BEFORE rendering\n\t\t\tif (this.vscode && this._isInitialLoad) {\n\t\t\t\tthis.vscode.postMessage({\n\t\t\t\t\ttype: 'formatInfo',\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\tchannels: channels,\n\t\t\t\t\t\tsamplesPerPixel: channels,\n\t\t\t\t\t\tdataType: type === 1016 ? 'float16' : 'float32',\n\t\t\t\t\t\tisHdr: true,\n\t\t\t\t\t\tformatLabel: 'EXR',\n\t\t\t\t\t\tformatType: 'exr-float', // For per-format settings\n\t\t\t\t\t\tisInitialLoad: true // Signal that this is the first load\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Store pending render data - will render when settings are updated\n\t\t\t\tthis._pendingRenderData = { width, height, data, channels, type, format };\n\n\t\t\t\t// Return placeholder - actual rendering happens when settings update\n\t\t\t\tconst placeholderImageData = new ImageData(width, height);\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\timageData: placeholderImageData,\n\t\t\t\t\texrData: this.rawExrData\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If not initial load, render immediately with current settings\n\t\t\tconst imageData = this.renderExrToCanvas(canvas, this.settingsManager.settings);\n\n\t\t\treturn {\n\t\t\t\tcanvas: canvas,\n\t\t\t\timageData: imageData,\n\t\t\t\texrData: this.rawExrData\n\t\t\t};\n\n\t\t} catch (error) {\n\t\t\tconsole.error('Error processing EXR:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Render EXR data to canvas with current settings\n\t * @param {HTMLCanvasElement} canvas - Target canvas\n\t * @param {Object} settings - Current rendering settings\n\t * @returns {ImageData} - Rendered image data\n\t */\n\trenderExrToCanvas(canvas, settings) {\n\t\tif (!this.rawExrData) {\n\t\t\tthrow new Error('No EXR data loaded');\n\t\t}\n\n\t\tconst { width, height, data, channels } = this.rawExrData;\n\t\tconst ctx = canvas.getContext('2d');\n\t\tconst isGammaMode = settings.normalization?.gammaMode || false;\n\n\t\t// Calculate stats if needed (for auto-normalize or just to have them)\n\t\t/** @type {{min: number, max: number} | undefined} */\n\t\tlet stats = this._cachedStats;\n\t\tif (!stats && !isGammaMode) {\n\t\t\tstats = ImageStatsCalculator.calculateFloatStats(data, width, height, channels);\n\t\t\tthis._cachedStats = stats;\n\n\t\t\t// Only update settings if auto-normalize is enabled (don't overwrite manual values!)\n\t\t\tconst isAutoNormalize = settings.normalization?.autoNormalize !== false;\n\t\t\tif (isAutoNormalize && this.settingsManager && this.settingsManager.settings.normalization) {\n\t\t\t\tthis.settingsManager.settings.normalization.min = stats.min;\n\t\t\t\tthis.settingsManager.settings.normalization.max = stats.max;\n\t\t\t}\n\t\t}\n\n\t\tconst nanColor = this._getNanColor(settings);\n\n\t\t// Create options object\n\t\tconst options = {\n\t\t\tnanColor: nanColor,\n\t\t\t// EXR data is typically bottom-up, so we need to flip it for display\n\t\t\tflipY: true\n\t\t};\n\n\t\tconst imageData = ImageRenderer.render(\n\t\t\tdata,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tchannels,\n\t\t\ttrue, // isFloat\n\t\t\tstats || { min: 0, max: 1 },\n\t\t\tsettings,\n\t\t\toptions\n\t\t);\n\n\t\tctx.putImageData(imageData, 0, 0);\n\t\treturn imageData;\n\t}\n\n\t/**\n\t * Get pixel value at coordinates for inspection\n\t * @param {number} x - X coordinate\n\t * @param {number} y - Y coordinate\n\t * @returns {Array<number>} - Pixel values (raw HDR values)\n\t */\n\tgetPixelValue(x, y) {\n\t\tif (!this.rawExrData) return null;\n\n\t\tconst { width, height, data, channels } = this.rawExrData;\n\t\tif (x < 0 || x >= width || y < 0 || y >= height) return null;\n\n\t\t// Apply Y-flip to match rendering (EXR uses bottom-left origin, canvas uses top-left)\n\t\tconst flippedY = height - 1 - y;\n\t\tconst dataIndex = (flippedY * width + x) * channels;\n\t\tconst values = [];\n\t\tfor (let i = 0; i < channels; i++) {\n\t\t\tvalues.push(data[dataIndex + i]);\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Update rendering with new settings (called when settings change)\n\t * @param {Object} settings - New settings\n\t * @returns {ImageData|null} - Updated image data\n\t */\n\tupdateSettings(settings) {\n\t\tif (this._pendingRenderData && this._isInitialLoad) {\n\t\t\t// First render after initial load - use pending data\n\t\t\tconst { width, height } = this._pendingRenderData;\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst imageData = this.renderExrToCanvas(canvas, settings);\n\t\t\tthis._isInitialLoad = false;\n\t\t\tthis._pendingRenderData = null;\n\n\t\t\treturn imageData;\n\t\t} else if (this.rawExrData) {\n\t\t\t// Re-render with new settings\n\t\t\tconst { width, height } = this.rawExrData;\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\treturn this.renderExrToCanvas(canvas, settings);\n\t\t}\n\t\treturn null;\n\t}\n}\n", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\n\n/**\n * Convert IEEE 754 half-precision (float16) to single-precision (float32)\n * @param {number} uint16 - The 16-bit representation\n * @returns {number} The float32 value\n */\nfunction float16ToFloat32(uint16) {\n    const sign = (uint16 & 0x8000) >> 15;\n    const exponent = (uint16 & 0x7C00) >> 10;\n    const fraction = uint16 & 0x03FF;\n\n    if (exponent === 0) {\n        // Subnormal or zero\n        if (fraction === 0) {\n            return sign ? -0.0 : 0.0;\n        }\n        // Subnormal numbers\n        return (sign ? -1 : 1) * Math.pow(2, -14) * (fraction / 1024);\n    } else if (exponent === 0x1F) {\n        // Infinity or NaN\n        return fraction ? NaN : (sign ? -Infinity : Infinity);\n    }\n\n    // Normalized number\n    return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + fraction / 1024);\n}\n\n/**\n * NPY/NPZ Processor for TIFF Visualizer\n * Parses NumPy .npy and .npz files and renders them to ImageData\n */\nexport class NpyProcessor {\n    constructor(settingsManager, vscode) {\n        this.settingsManager = settingsManager;\n        this.vscode = vscode;\n        this._lastRaw = null; // { width, height, data: Float32Array, dtype: string, showNorm: boolean }\n        this._pendingRenderData = null; // Store data waiting for format-specific settings\n        this._isInitialLoad = true; // Track if this is the first render\n        /** @type {{min: number, max: number} | undefined} */\n        this._cachedStats = undefined; // Cache for min/max stats (only used in stats mode)\n    }\n\n    async processNpy(src) {\n        // Invalidate stats cache for new image\n        this._cachedStats = undefined;\n\n        const response = await fetch(src);\n        const buffer = await response.arrayBuffer();\n        const view = new DataView(buffer);\n\n        // NPZ (ZIP) signature 0x04034b50\n        if (buffer.byteLength >= 4 && view.getUint32(0, true) === 0x04034b50) {\n            const { data, width, height, dtype, showNorm, channels } = this._parseNpz(buffer);\n            this._lastRaw = { width, height, data, dtype, showNorm, channels };\n\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n\n            // Send format info BEFORE rendering (for deferred rendering)\n            if (this._isInitialLoad) {\n                this._postFormatInfo(width, height, 'NPY');\n                this._pendingRenderData = { data, width, height };\n                // Return placeholder\n                const placeholderImageData = new ImageData(width, height);\n                return { canvas, imageData: placeholderImageData };\n            }\n\n            // Non-initial loads - render immediately\n            const imageData = this._toImageDataFloat(data, width, height);\n            this.vscode.postMessage({ type: 'refresh-status' });\n            return { canvas, imageData };\n        }\n\n        const { data, width, height, dtype, showNorm, channels } = this._parseNpy(buffer);\n        this._lastRaw = { width, height, data, dtype, showNorm, channels };\n\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        // Send format info BEFORE rendering (for deferred rendering)\n        if (this._isInitialLoad) {\n            this._postFormatInfo(width, height, 'NPY');\n            this._pendingRenderData = { data, width, height };\n            // Return placeholder\n            const placeholderImageData = new ImageData(width, height);\n            return { canvas, imageData: placeholderImageData };\n        }\n\n        // Non-initial loads - render immediately\n        const imageData = this._toImageDataFloat(data, width, height);\n        this.vscode.postMessage({ type: 'refresh-status' });\n        return { canvas, imageData };\n    }\n\n    _parseNpy(arrayBuffer) {\n        const view = new DataView(arrayBuffer);\n        // Magic '\\x93NUMPY'\n        const magic = new Uint8Array(arrayBuffer, 0, 6);\n        const expected = [0x93, 0x4E, 0x55, 0x4D, 0x50, 0x59];\n        for (let i = 0; i < 6; i++) {\n            if (magic[i] !== expected[i]) {\n                throw new Error('Invalid NPY file');\n            }\n        }\n        const major = view.getUint8(6);\n        const minor = view.getUint8(7);\n        if (major !== 1 && major !== 2) {\n            throw new Error(`Unsupported NPY version ${major}.${minor}`);\n        }\n        const headerLen = major === 1 ? view.getUint16(8, true) : view.getUint32(8, true);\n        const headerStart = major === 1 ? 10 : 12;\n        const headerBytes = new Uint8Array(arrayBuffer, headerStart, headerLen);\n        const header = new TextDecoder('latin1').decode(headerBytes);\n        const shapeMatch = header.match(/'shape':\\s*\\(([^)]+)\\)/);\n        if (!shapeMatch) throw new Error('NPY missing shape');\n        const dims = shapeMatch[1].split(',').map(s => s.trim()).filter(Boolean).map(s => parseInt(s, 10));\n        const dtypeMatch = header.match(/'descr':\\s*'([^']+)'/);\n        if (!dtypeMatch) throw new Error('NPY missing dtype');\n        const dtype = dtypeMatch[1];\n\n        // Determine if this is a float type\n        const showNorm = dtype.includes('f');\n\n        let height, width, channels = 1;\n        if (dims.length === 2) {\n            height = dims[0];\n            width = dims[1];\n        } else if (dims.length === 3) {\n            height = dims[0];\n            width = dims[1];\n            channels = dims[2];\n        } else {\n            throw new Error(`Unsupported NPY dims ${dims.length}`);\n        }\n        const elems = width * height * channels;\n        const off = headerStart + headerLen;\n        let raw;\n        if (dtype === '<f4' || dtype === '=f4') {\n            raw = new Float32Array(arrayBuffer, off, elems);\n        } else if (dtype === '>f4') {\n            const bytes = new Uint8Array(arrayBuffer, off, elems * 4);\n            raw = new Float32Array(elems);\n            for (let i = 0; i < elems; i++) {\n                const j = i * 4;\n                const b0 = bytes[j + 3];\n                const b1 = bytes[j + 2];\n                const b2 = bytes[j + 1];\n                const b3 = bytes[j + 0];\n                raw[i] = new Float32Array(new Uint8Array([b0, b1, b2, b3]).buffer)[0];\n            }\n        } else if (dtype.endsWith('f8')) {\n            const src = new Float64Array(arrayBuffer, off, elems);\n            raw = new Float32Array(elems);\n            for (let i = 0; i < elems; i++) raw[i] = src[i];\n        } else if (dtype.includes('f2')) {\n            // Float16 (half precision) - JavaScript doesn't have native Float16Array\n            // We need to decode manually\n            const bytes = new Uint8Array(arrayBuffer, off, elems * 2);\n            const little = dtype.startsWith('<') || dtype.startsWith('=');\n            raw = new Float32Array(elems);\n            for (let i = 0; i < elems; i++) {\n                const p = i * 2;\n                const uint16 = little ?\n                    bytes[p] | (bytes[p + 1] << 8) :\n                    (bytes[p] << 8) | bytes[p + 1];\n                raw[i] = float16ToFloat32(uint16);\n            }\n        } else {\n            // Fallback for integers\n            const bytes = parseInt(dtype.slice(-1), 10);\n            const little = dtype.startsWith('<') || dtype.startsWith('=');\n            const dv = new DataView(arrayBuffer, off);\n            raw = new Float32Array(elems);\n            for (let i = 0; i < elems; i++) {\n                const p = i * bytes;\n                let v = 0;\n                if (bytes === 1) v = dtype.includes('u') ? dv.getUint8(p) : dv.getInt8(p);\n                else if (bytes === 2) v = dtype.includes('u') ? dv.getUint16(p, little) : dv.getInt16(p, little);\n                else if (bytes === 4) v = dtype.includes('u') ? dv.getUint32(p, little) : dv.getInt32(p, little);\n                else v = Number(dtype.includes('u') ? dv.getBigUint64(p, little) : dv.getBigInt64(p, little));\n                raw[i] = v;\n            }\n        }\n        let data;\n        if (channels === 1) {\n            data = raw;\n        } else if (channels === 3 || channels === 4) {\n            // Keep RGB/RGBA data intact\n            data = raw;\n        } else {\n            // For other channel counts, take first channel only\n            data = new Float32Array(width * height);\n            for (let i = 0; i < width * height; i++) data[i] = raw[i * channels + 0];\n        }\n        return { data, width, height, dtype, showNorm, channels };\n    }\n\n    _parseNpz(arrayBuffer) {\n        const view = new DataView(arrayBuffer);\n        let offset = 0;\n        const arrays = {};\n        while (offset < arrayBuffer.byteLength - 4) {\n            const sig = view.getUint32(offset, true);\n            if (sig !== 0x04034b50) { offset++; continue; }\n            const comp = view.getUint16(offset + 8, true);\n            const nameLen = view.getUint16(offset + 26, true);\n            const extraLen = view.getUint16(offset + 28, true);\n            const compSize = view.getUint32(offset + 18, true);\n            const fileName = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 30, nameLen));\n            const dataOffset = offset + 30 + nameLen + extraLen;\n            if (fileName.endsWith('.npy') && comp === 0) {\n                const slice = arrayBuffer.slice(dataOffset, dataOffset + compSize);\n                const { data, width, height, dtype, showNorm, channels } = this._parseNpy(slice);\n                arrays[fileName.replace('.npy', '')] = { data, width, height, dtype, showNorm, channels };\n            }\n            offset = dataOffset + compSize;\n        }\n        // Choose best candidate\n        const keys = Object.keys(arrays);\n        if (keys.length === 0) throw new Error('NPZ contains no uncompressed .npy arrays');\n        let pick = keys.find(k => /depth|dispar|inv|z|range/i.test(k));\n        if (!pick) pick = keys[0];\n        const a = arrays[pick];\n        return { data: a.data, width: a.width, height: a.height, dtype: a.dtype, showNorm: a.showNorm, channels: a.channels };\n    }\n\n    _toImageDataFloat(data, width, height) {\n        const channels = this._lastRaw?.channels || 1;\n        const settings = this.settingsManager.settings;\n        const rgbAs24BitMode = settings.rgbAs24BitGrayscale && channels === 3;\n        const dtype = this._lastRaw?.dtype || 'f4';\n        const isFloat = dtype.includes('f');\n        const isGammaMode = settings.normalization?.gammaMode || false;\n\n        // Calculate stats if needed (for auto-normalize or just to have them)\n        /** @type {{min: number, max: number} | undefined} */\n        let stats = this._cachedStats;\n\n        if (!stats && !isGammaMode) {\n            if (isFloat) {\n                stats = ImageStatsCalculator.calculateFloatStats(data, width, height, channels);\n            } else {\n                stats = ImageStatsCalculator.calculateIntegerStats(data, width, height, channels, rgbAs24BitMode);\n            }\n            this._cachedStats = stats;\n\n            if (this.vscode) {\n                this.vscode.postMessage({ type: 'stats', value: stats });\n            }\n        }\n\n        const nanColor = this._getNanColor(settings);\n\n        // Determine typeMax for integer types\n        let typeMax;\n        if (!isFloat) {\n            if (dtype.includes('1')) typeMax = 255;\n            else if (dtype.includes('2')) typeMax = 65535;\n            else if (dtype.includes('4')) typeMax = 4294967295; // 32-bit\n        }\n\n        // Create options object\n        const options = {\n            nanColor: nanColor,\n            rgbAs24BitGrayscale: rgbAs24BitMode,\n            flipY: false, // NPY is usually top-down\n            typeMax: typeMax\n        };\n\n        return ImageRenderer.render(\n            data,\n            width,\n            height,\n            channels,\n            true, // Always true since NPY stores everything as Float32Array\n            stats || { min: 0, max: 1 },\n            settings,\n            options\n        );\n    }\n\n\n    /**\n     * Re-render NPY with current settings (for real-time updates)\n     * @returns {ImageData | null}\n     */\n    renderNpyWithSettings() {\n        if (!this._lastRaw) return null;\n        const { width, height, data } = this._lastRaw;\n        return this._toImageDataFloat(data, width, height);\n    }\n\n    getColorAtPixel(x, y, naturalWidth, naturalHeight) {\n        if (!this._lastRaw) return '';\n        const { width, height, data, channels, dtype } = this._lastRaw;\n        if (width !== naturalWidth || height !== naturalHeight) return '';\n\n        const pixelIdx = y * width + x;\n        const settings = this.settingsManager.settings;\n        const rgbAs24BitMode = settings.rgbAs24BitGrayscale && channels === 3;\n        const normalizedFloatMode = settings.normalizedFloatMode;\n\n        if (rgbAs24BitMode) {\n            // RGB as 24-bit grayscale: show combined value\n            const srcIdx = pixelIdx * 3;\n            const rVal = Math.round(Math.max(0, Math.min(255, data[srcIdx + 0])));\n            const gVal = Math.round(Math.max(0, Math.min(255, data[srcIdx + 1])));\n            const bVal = Math.round(Math.max(0, Math.min(255, data[srcIdx + 2])));\n            const combined24bit = (rVal << 16) | (gVal << 8) | bVal;\n\n            // Apply scale factor for display\n            const scaleFactor = settings.scale24BitFactor || 1000;\n            const scaledValue = (combined24bit / scaleFactor).toFixed(3);\n            return scaledValue;\n        } else if (channels === 3) {\n            // RGB data - return space-separated values (avoid scientific notation)\n            const srcIdx = pixelIdx * 3;\n            const r = data[srcIdx + 0];\n            const g = data[srcIdx + 1];\n            const b = data[srcIdx + 2];\n            if (Number.isFinite(r) && Number.isFinite(g) && Number.isFinite(b)) {\n                const formatNumber = (n) => {\n                    // Use fixed decimal notation to avoid scientific notation\n                    // Show up to 6 decimal places, but remove trailing zeros\n                    return parseFloat(n.toFixed(6)).toString();\n                };\n                return `${formatNumber(r)} ${formatNumber(g)} ${formatNumber(b)}`;\n            }\n        } else if (channels === 4) {\n            // RGBA data - return space-separated values with \u03B1: prefix for alpha\n            const srcIdx = pixelIdx * 4;\n            const r = data[srcIdx + 0];\n            const g = data[srcIdx + 1];\n            const b = data[srcIdx + 2];\n            const a = data[srcIdx + 3];\n            if (Number.isFinite(r) && Number.isFinite(g) && Number.isFinite(b) && Number.isFinite(a)) {\n                const formatNumber = (n) => {\n                    // Use fixed decimal notation to avoid scientific notation\n                    // Show up to 6 decimal places, but remove trailing zeros\n                    return parseFloat(n.toFixed(6)).toString();\n                };\n                return `${formatNumber(r)} ${formatNumber(g)} ${formatNumber(b)} \u03B1:${formatNumber(a)}`;\n            }\n        } else {\n            // Grayscale data\n            const value = data[pixelIdx];\n            if (Number.isFinite(value)) {\n                const formatNumber = (n) => {\n                    // Use fixed decimal notation to avoid scientific notation\n                    // Show up to 6 decimal places, but remove trailing zeros\n                    return parseFloat(n.toFixed(6)).toString();\n                };\n                // Check if normalized float mode is enabled for uint images\n                if (normalizedFloatMode && dtype && !dtype.includes('f')) {\n                    // Convert uint to normalized float (0-1)\n                    let maxValue = 255;\n                    if (dtype.includes('u2') || dtype.includes('i2')) {\n                        maxValue = dtype.includes('u') ? 65535 : 32767;\n                    } else if (dtype.includes('u4') || dtype.includes('i4')) {\n                        maxValue = dtype.includes('u') ? 4294967295 : 2147483647;\n                    }\n                    const normalized = value / maxValue;\n                    return formatNumber(normalized);\n                }\n                return formatNumber(value);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * Send format info to VS Code\n     * @param {number} width - Image width\n     * @param {number} height - Image height\n     * @param {string} formatLabel - Format label\n     */\n    _postFormatInfo(width, height, formatLabel) {\n        if (!this.vscode) return;\n\n        // Determine actual bit depth and sample format from dtype\n        let bitsPerSample = 32;\n        let sampleFormat = 3; // Float\n\n        if (this._lastRaw && this._lastRaw.dtype) {\n            const dtype = this._lastRaw.dtype;\n\n            // Determine sample format: 1=uint, 2=int, 3=float\n            if (dtype.includes('f')) {\n                sampleFormat = 3; // Float\n                if (dtype.includes('f2')) bitsPerSample = 16;\n                else if (dtype.includes('f4')) bitsPerSample = 32;\n                else if (dtype.includes('f8')) bitsPerSample = 64;\n            } else if (dtype.includes('u')) {\n                sampleFormat = 1; // Unsigned int\n                if (dtype.includes('u1')) bitsPerSample = 8;\n                else if (dtype.includes('u2')) bitsPerSample = 16;\n                else if (dtype.includes('u4')) bitsPerSample = 32;\n                else if (dtype.includes('u8')) bitsPerSample = 64;\n            } else if (dtype.includes('i')) {\n                sampleFormat = 2; // Signed int\n                if (dtype.includes('i1')) bitsPerSample = 8;\n                else if (dtype.includes('i2')) bitsPerSample = 16;\n                else if (dtype.includes('i4')) bitsPerSample = 32;\n                else if (dtype.includes('i8')) bitsPerSample = 64;\n            }\n        }\n\n        const channels = this._lastRaw?.channels || 1;\n\n        // Determine specific NPY format type for per-format settings\n        let formatType = 'npy';\n        if (sampleFormat === 3) {\n            formatType = 'npy-float';\n        } else if (sampleFormat === 1 || sampleFormat === 2) {\n            formatType = 'npy-uint';\n        }\n\n        this.vscode.postMessage({\n            type: 'formatInfo',\n            value: {\n                width,\n                height,\n                compression: '1',\n                predictor: 3,\n                photometricInterpretation: channels >= 3 ? 2 : 1,\n                planarConfig: 1,\n                samplesPerPixel: channels,\n                bitsPerSample,\n                sampleFormat,\n                formatLabel,\n                formatType, // For per-format settings: 'npy-float' or 'npy-uint'\n                isInitialLoad: this._isInitialLoad // Signal that this is the first load\n            }\n        });\n    }\n\n    /**\n     * Perform the initial render if it was deferred\n     * Called when format-specific settings have been applied\n     * @returns {ImageData|null} - The rendered image data, or null if no pending render\n     */\n    performDeferredRender() {\n        if (!this._pendingRenderData) {\n            return null;\n        }\n\n        const { data, width, height } = this._pendingRenderData;\n        this._pendingRenderData = null;\n        this._isInitialLoad = false;\n\n        // Now render with the correct format-specific settings\n        const imageData = this._toImageDataFloat(data, width, height);\n\n        // Force status refresh so normalization UI appears\n        this.vscode.postMessage({ type: 'refresh-status' });\n\n        return imageData;\n    }\n\n    /**\n     * Get NaN color from settings\n     * @param {Object} settings\n     * @returns {{r: number, g: number, b: number}}\n     */\n    _getNanColor(settings) {\n        if (settings.nanColor) {\n            // Handle hex string\n            if (typeof settings.nanColor === 'string') {\n                const hex = settings.nanColor.replace('#', '');\n                return {\n                    r: parseInt(hex.substring(0, 2), 16),\n                    g: parseInt(hex.substring(2, 4), 16),\n                    b: parseInt(hex.substring(4, 6), 16)\n                };\n            }\n            // Handle object\n            return settings.nanColor;\n        }\n        return { r: 255, g: 0, b: 0 }; // Default red\n    }\n}\n\n\n", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\n\n/**\n * PFM Processor for TIFF Visualizer\n * Supports grayscale (Pf) and RGB (PF) portable float map files\n */\nexport class PfmProcessor {\n    constructor(settingsManager, vscode) {\n        this.settingsManager = settingsManager;\n        this.vscode = vscode;\n        this._lastRaw = null; // { width, height, data: Float32Array }\n        this._pendingRenderData = null; // Store data waiting for format-specific settings\n        this._isInitialLoad = true; // Track if this is the first render\n        /** @type {{min: number, max: number} | undefined} */\n        this._cachedStats = undefined; // Cache for min/max stats (only used in stats mode)\n    }\n\n    async processPfm(src) {\n        const response = await fetch(src);\n        const buffer = await response.arrayBuffer();\n        const { width, height, channels, data } = this._parsePfm(buffer);\n        // Keep color data for RGB PFM files\n        let displayData = data;\n\n        // PFM format stores rows from bottom to top, so we need to flip vertically\n        displayData = this._flipImageVertically(displayData, width, height, channels);\n\n        // Invalidate stats cache for new image\n        this._cachedStats = undefined;\n\n        this._lastRaw = { width, height, data: displayData, channels };\n\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        // Send format info BEFORE rendering (for deferred rendering)\n        if (this._isInitialLoad) {\n            this._postFormatInfo(width, height, channels, 'PFM');\n            this._pendingRenderData = { displayData, width, height, channels };\n            // Return placeholder\n            const placeholderImageData = new ImageData(width, height);\n            return { canvas, imageData: placeholderImageData };\n        }\n\n        // Non-initial loads - render immediately\n        this._postFormatInfo(width, height, channels, 'PFM');\n        const imageData = this._toImageDataFloat(displayData, width, height, channels);\n        this.vscode.postMessage({ type: 'refresh-status' });\n        return { canvas, imageData };\n    }\n\n    _parsePfm(arrayBuffer) {\n        const text = new TextDecoder('ascii').decode(arrayBuffer);\n        // Read header lines\n        const lines = text.split(/\\n/);\n        let idx = 0;\n        while (idx < lines.length && lines[idx].trim() === '') idx++;\n        const type = lines[idx++].trim();\n        if (type !== 'PF' && type !== 'Pf') throw new Error('Invalid PFM magic');\n        // Skip comments\n        while (idx < lines.length && lines[idx].trim().startsWith('#')) idx++;\n        const dims = lines[idx++].trim().split(/\\s+/).map(n => parseInt(n, 10));\n        const width = dims[0];\n        const height = dims[1];\n        const scale = parseFloat(lines[idx++].trim());\n        const littleEndian = scale < 0;\n        const channels = type === 'PF' ? 3 : 1;\n        // Find start byte offset of pixel data\n        const headerUpTo = lines.slice(0, idx).join('\\n') + '\\n';\n        const headerBytes = new TextEncoder().encode(headerUpTo).length;\n        const bytesPerPixel = 4 * channels;\n        const dv = new DataView(arrayBuffer, headerBytes);\n        const pixels = width * height;\n        const out = new Float32Array(pixels * channels);\n        let o = 0;\n        for (let i = 0; i < pixels; i++) {\n            for (let c = 0; c < channels; c++) {\n                const v = dv.getFloat32((i * channels + c) * 4, littleEndian);\n                out[o++] = v;\n            }\n        }\n        return { width, height, channels, data: out };\n    }\n\n    _toImageDataFloat(data, width, height, channels = 1) {\n        const settings = this.settingsManager.settings;\n        const isGammaMode = settings.normalization?.gammaMode || false;\n\n        // Calculate stats if needed (for auto-normalize or just to have them)\n        /** @type {{min: number, max: number} | undefined} */\n        let stats = this._cachedStats;\n        if (!stats && !isGammaMode) {\n            stats = ImageStatsCalculator.calculateFloatStats(data, width, height, channels);\n            this._cachedStats = stats;\n\n            if (this.vscode) {\n                this.vscode.postMessage({ type: 'stats', value: stats });\n            }\n        }\n\n        // Use centralized ImageRenderer\n        return ImageRenderer.render(\n            data,\n            width,\n            height,\n            channels,\n            true, // isFloat (float32)\n            stats || { min: 0, max: 1 },\n            settings,\n            {} // No special options for PFM\n        );\n    }\n\n    getColorAtPixel(x, y, naturalWidth, naturalHeight) {\n        if (!this._lastRaw) return '';\n        const { width, height, data, channels } = this._lastRaw;\n        if (width !== naturalWidth || height !== naturalHeight) return '';\n\n        const idx = y * width + x;\n\n        // Helper to format individual values (avoid scientific notation)\n        const formatValue = (v) => {\n            if (Number.isNaN(v)) return 'NaN';\n            if (v === Infinity) return 'Inf';\n            if (v === -Infinity) return '-Inf';\n            // Use fixed decimal notation to avoid scientific notation\n            // Show up to 6 decimal places, but remove trailing zeros\n            return parseFloat(v.toFixed(6)).toString();\n        };\n\n        if (channels === 3) {\n            // RGB data - return space-separated values\n            const baseIdx = idx * 3;\n            if (baseIdx >= 0 && baseIdx + 2 < data.length) {\n                const r = data[baseIdx];\n                const g = data[baseIdx + 1];\n                const b = data[baseIdx + 2];\n                return `${formatValue(r)} ${formatValue(g)} ${formatValue(b)}`;\n            }\n        } else {\n            // Grayscale data\n            const value = data[idx];\n            return formatValue(value);\n        }\n        return '';\n    }\n\n    _postFormatInfo(width, height, channels, formatLabel) {\n        if (!this.vscode) return;\n        this.vscode.postMessage({\n            type: 'formatInfo',\n            value: {\n                width,\n                height,\n                compression: '1',\n                predictor: 3,\n                photometricInterpretation: channels === 3 ? 2 : 1,\n                planarConfig: 1,\n                samplesPerPixel: channels,\n                bitsPerSample: 32,\n                sampleFormat: 3,\n                formatLabel,\n                formatType: 'pfm', // For per-format settings\n                isInitialLoad: this._isInitialLoad // Signal that this is the first load\n            }\n        });\n    }\n\n    /**\n     * Perform the initial render if it was deferred\n     * Called when format-specific settings have been applied\n     * @returns {ImageData|null} - The rendered image data, or null if no pending render\n     */\n    performDeferredRender() {\n        if (!this._pendingRenderData) {\n            return null;\n        }\n\n        const { displayData, width, height, channels } = this._pendingRenderData;\n        this._pendingRenderData = null;\n        this._isInitialLoad = false;\n\n        // Now render with the correct format-specific settings\n        const imageData = this._toImageDataFloat(displayData, width, height, channels);\n\n        // Force status refresh\n        this.vscode.postMessage({ type: 'refresh-status' });\n\n        return imageData;\n    }\n\n    /**\n     * Update settings and trigger re-render\n     * @param {Object} settings - New settings\n     */\n    updateSettings(settings) {\n        this.settingsManager.updateSettings(settings);\n        // Invalidate cached stats when settings change (especially for auto-normalize)\n        if (settings.normalization?.autoNormalize !== this.settingsManager.settings.normalization?.autoNormalize) {\n            this._cachedStats = null;\n        }\n        // Post message to trigger re-render in main code\n        if (this.vscode) {\n            this.vscode.postMessage({ type: 'settings-updated' });\n        }\n    }\n\n    _flipImageVertically(data, width, height, channels = 1) {\n        const flipped = new Float32Array(data.length);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (channels === 3) {\n                    // RGB data - flip each channel\n                    const srcIdx = (y * width + x) * 3;\n                    const dstIdx = ((height - 1 - y) * width + x) * 3;\n                    flipped[dstIdx] = data[srcIdx];         // R\n                    flipped[dstIdx + 1] = data[srcIdx + 1]; // G\n                    flipped[dstIdx + 2] = data[srcIdx + 2]; // B\n                } else {\n                    // Grayscale data\n                    const srcIdx = y * width + x;\n                    const dstIdx = (height - 1 - y) * width + x;\n                    flipped[dstIdx] = data[srcIdx];\n                }\n            }\n        }\n        return flipped;\n    }\n}\n\n\n", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\n\n/**\n * PPM/PGM Processor for TIFF Visualizer\n * Supports PGM (grayscale) and PPM (RGB) portable pixmap files\n * Both ASCII (P2/P3) and binary (P5/P6) formats\n */\nexport class PpmProcessor {\n    constructor(settingsManager, vscode) {\n        this.settingsManager = settingsManager;\n        this.vscode = vscode;\n        this._lastRaw = null; // { width, height, data: Uint8Array|Uint16Array, maxval, channels }\n        this._pendingRenderData = null; // Store data waiting for format-specific settings\n        this._isInitialLoad = true; // Track if this is the first render\n        this._cachedStats = undefined; // Cache for min/max stats (only used in stats mode)\n    }\n\n    async processPpm(src) {\n        const response = await fetch(src);\n        const buffer = await response.arrayBuffer();\n        const { width, height, channels, data, maxval, format } = this._parsePpm(buffer);\n\n        // Keep RGB data for color display\n        const displayData = data;\n\n        // PPM stores pixels from top-to-bottom, which is the correct orientation for canvas\n        // No flipping needed unless specifically required by the format\n\n        // Invalidate stats cache for new image\n        this._cachedStats = undefined;\n\n        this._lastRaw = { width, height, data: displayData, maxval, channels };\n\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        // Send format info BEFORE rendering (for deferred rendering)\n        if (this._isInitialLoad) {\n            this._postFormatInfo(width, height, channels, format, maxval);\n            this._pendingRenderData = { displayData, width, height, maxval, channels };\n            // Return placeholder\n            const placeholderImageData = new ImageData(width, height);\n            return { canvas, imageData: placeholderImageData };\n        }\n\n        // Non-initial loads - render immediately\n        this._postFormatInfo(width, height, channels, format, maxval);\n        const imageData = this._toImageDataWithNormalization(displayData, width, height, maxval, channels);\n        this.vscode.postMessage({ type: 'refresh-status' });\n        return { canvas, imageData };\n    }\n\n    _parsePpm(arrayBuffer) {\n        const uint8Array = new Uint8Array(arrayBuffer);\n        let offset = 0;\n\n        // Helper function to read next token\n        const readToken = () => {\n            // Skip whitespace and comments\n            while (offset < uint8Array.length) {\n                const char = uint8Array[offset];\n                if (char === 35) { // '#' - comment\n                    // Skip to end of line\n                    while (offset < uint8Array.length && uint8Array[offset] !== 10) {\n                        offset++;\n                    }\n                    if (offset < uint8Array.length) offset++; // Skip newline\n                } else if (char === 32 || char === 9 || char === 10 || char === 13) { // whitespace\n                    offset++;\n                } else {\n                    break;\n                }\n            }\n\n            // Read token\n            let token = '';\n            while (offset < uint8Array.length) {\n                const char = uint8Array[offset];\n                if (char === 32 || char === 9 || char === 10 || char === 13 || char === 35) {\n                    break;\n                }\n                token += String.fromCharCode(char);\n                offset++;\n            }\n            return token;\n        };\n\n        // Read magic number\n        const magic = readToken();\n        if (!['P1', 'P2', 'P3', 'P4', 'P5', 'P6'].includes(magic)) {\n            throw new Error(`Invalid PPM/PGM/PBM magic number: ${magic}`);\n        }\n\n        const isAscii = magic === 'P1' || magic === 'P2' || magic === 'P3';\n        const channels = (magic === 'P1' || magic === 'P4' || magic === 'P2' || magic === 'P5') ? 1 : 3;\n        const format = magic === 'P1' ? 'PBM (ASCII)' :\n            magic === 'P2' ? 'PGM (ASCII)' :\n                magic === 'P3' ? 'PPM (ASCII)' :\n                    magic === 'P4' ? 'PBM (Binary)' :\n                        magic === 'P5' ? 'PGM (Binary)' : 'PPM (Binary)';\n        const isPbm = magic === 'P1' || magic === 'P4';\n\n        // Read dimensions\n        const width = parseInt(readToken(), 10);\n        const height = parseInt(readToken(), 10);\n        // PBM files don't have maxval, only PGM/PPM do\n        const maxval = isPbm ? 1 : parseInt(readToken(), 10);\n\n        if (width <= 0 || height <= 0 || (!isPbm && maxval <= 0)) {\n            throw new Error('Invalid PPM/PGM/PBM dimensions or maxval');\n        }\n\n        const pixelCount = width * height;\n        const totalValues = pixelCount * channels;\n\n        // Determine data type based on maxval\n        const use16bit = !isPbm && maxval > 255;\n        const DataType = use16bit ? Uint16Array : Uint8Array;\n        const data = new DataType(totalValues);\n\n        if (isPbm && isAscii) {\n            // PBM ASCII format (P1) - read 0s and 1s\n            for (let i = 0; i < totalValues; i++) {\n                const token = readToken();\n                const value = parseInt(token, 10);\n                if (value !== 0 && value !== 1) {\n                    throw new Error(`Invalid PBM pixel value: ${token} (must be 0 or 1)`);\n                }\n                // Convert 0=white to 255, 1=black to 0 for display\n                data[i] = value === 0 ? 255 : 0;\n            }\n        } else if (isPbm && !isAscii) {\n            // PBM binary format (P4) - packed bits\n            const bytesPerRow = Math.ceil(width / 8);\n            const expectedBytes = bytesPerRow * height;\n\n            if (offset + expectedBytes > uint8Array.length) {\n                throw new Error('Insufficient data for binary PBM');\n            }\n\n            let dataIdx = 0;\n            for (let row = 0; row < height; row++) {\n                for (let col = 0; col < width; col++) {\n                    const byteIdx = offset + row * bytesPerRow + Math.floor(col / 8);\n                    const bitIdx = 7 - (col % 8); // Most significant bit first\n                    const bit = (uint8Array[byteIdx] >> bitIdx) & 1;\n                    // Convert 0=white to 255, 1=black to 0 for display\n                    data[dataIdx++] = bit === 0 ? 255 : 0;\n                }\n            }\n        } else if (isAscii) {\n            // ASCII format - read space-separated values (P2/P3)\n            for (let i = 0; i < totalValues; i++) {\n                const token = readToken();\n                const value = parseInt(token, 10);\n                if (isNaN(value) || value < 0 || value > maxval) {\n                    throw new Error(`Invalid pixel value: ${token}`);\n                }\n                data[i] = value;\n            }\n        } else {\n            // Binary format (P5/P6)\n            // PPM spec: after maxval, there is exactly ONE whitespace character (usually newline),\n            // then the binary data starts immediately\n            // Skip the single whitespace separator\n            if (offset < uint8Array.length) {\n                const char = uint8Array[offset];\n                if (char === 32 || char === 9 || char === 10 || char === 13) {\n                    offset++;\n                }\n            }\n\n            const bytesPerValue = use16bit ? 2 : 1;\n            const expectedBytes = totalValues * bytesPerValue;\n\n            if (offset + expectedBytes > uint8Array.length) {\n                throw new Error('Insufficient data for binary PPM/PGM');\n            }\n\n            if (use16bit) {\n                // 16-bit values (big-endian as per PPM spec)\n                const dataView = new DataView(arrayBuffer, offset);\n                for (let i = 0; i < totalValues; i++) {\n                    data[i] = dataView.getUint16(i * 2, false); // false = big-endian\n                }\n            } else {\n                // 8-bit values\n                for (let i = 0; i < totalValues; i++) {\n                    data[i] = uint8Array[offset + i];\n                }\n            }\n        }\n\n        return { width, height, channels, data, maxval, format };\n    }\n\n\n\n    _toImageDataWithNormalization(data, width, height, maxval, channels = 1) {\n        const settings = this.settingsManager.settings;\n        const rgbAs24BitMode = settings.rgbAs24BitGrayscale && channels === 3;\n        const isGammaMode = settings.normalization?.gammaMode || false;\n\n        // Calculate stats if needed\n        let stats = this._cachedStats;\n        if (!stats && !isGammaMode) {\n            if (rgbAs24BitMode) {\n                // For 24-bit mode, compute stats from combined 24-bit values\n                let min = Infinity;\n                let max = -Infinity;\n                const len = width * height;\n\n                // Check if data is 16-bit to handle scaling correctly\n                const is16Bit = data instanceof Uint16Array;\n\n                for (let i = 0; i < len; i++) {\n                    const srcIdx = i * 3;\n                    let r, g, b;\n\n                    if (is16Bit) {\n                        r = Math.round(data[srcIdx] / 257);\n                        g = Math.round(data[srcIdx + 1] / 257);\n                        b = Math.round(data[srcIdx + 2] / 257);\n                    } else {\n                        r = data[srcIdx];\n                        g = data[srcIdx + 1];\n                        b = data[srcIdx + 2];\n                    }\n\n                    const combined24bit = (r << 16) | (g << 8) | b;\n                    if (combined24bit < min) min = combined24bit;\n                    if (combined24bit > max) max = combined24bit;\n                }\n                stats = { min, max };\n            } else {\n                stats = ImageStatsCalculator.calculateIntegerStats(data, width, height, channels);\n            }\n            this._cachedStats = stats;\n        }\n\n        // Create options object\n        const options = {\n            rgbAs24BitGrayscale: rgbAs24BitMode,\n            typeMax: rgbAs24BitMode ? 16777215 : maxval\n        };\n\n        return ImageRenderer.render(\n            data,\n            width,\n            height,\n            channels,\n            false, // isFloat\n            stats,\n            settings,\n            options\n        );\n    }\n\n\n    /**\n     * Re-render PPM/PGM with current settings (for real-time updates)\n     */\n    renderPgmWithSettings() {\n        if (!this._lastRaw) return null;\n        const { width, height, data, maxval, channels } = this._lastRaw;\n        return this._toImageDataWithNormalization(data, width, height, maxval, channels);\n    }\n\n    /**\n     * Get color at specific pixel\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @param {number} naturalWidth - Image natural width\n     * @param {number} naturalHeight - Image natural height\n     * @returns {string} Color string\n     */\n    getColorAtPixel(x, y, naturalWidth, naturalHeight) {\n        if (!this._lastRaw) return '';\n        const { width, height, data, channels, maxval } = this._lastRaw;\n        if (width !== naturalWidth || height !== naturalHeight) return '';\n\n        const settings = this.settingsManager.settings;\n        const rgbAs24BitMode = settings.rgbAs24BitGrayscale && channels === 3;\n        const normalizedFloatMode = settings.normalizedFloatMode;\n\n        const idx = y * width + x;\n        if (rgbAs24BitMode) {\n            // RGB as 24-bit grayscale: show combined value\n            const baseIdx = idx * 3;\n            if (baseIdx >= 0 && baseIdx + 2 < data.length) {\n                const r = Math.round(Math.max(0, Math.min(255, data[baseIdx])));\n                const g = Math.round(Math.max(0, Math.min(255, data[baseIdx + 1])));\n                const b = Math.round(Math.max(0, Math.min(255, data[baseIdx + 2])));\n                const combined24bit = (r << 16) | (g << 8) | b;\n\n                // Apply scale factor for display\n                const scaleFactor = settings.scale24BitFactor || 1000;\n                const scaledValue = (combined24bit / scaleFactor).toFixed(3);\n                return scaledValue;\n            }\n        } else if (channels === 3) {\n            // RGB data (normal mode) - return space-separated values\n            const baseIdx = idx * 3;\n            if (baseIdx >= 0 && baseIdx + 2 < data.length) {\n                const r = data[baseIdx];\n                const g = data[baseIdx + 1];\n                const b = data[baseIdx + 2];\n                return `${r} ${g} ${b}`;\n            }\n        } else {\n            // Grayscale data\n            if (idx >= 0 && idx < data.length) {\n                const value = data[idx];\n\n                // Check if normalized float mode is enabled\n                if (normalizedFloatMode) {\n                    // Convert uint to normalized float (0-1)\n                    const normalized = value / maxval;\n                    return normalized.toPrecision(4);\n                }\n\n                return value.toString();\n            }\n        }\n        return '';\n    }\n\n    _flipImageVertically(data, width, height) {\n        const flipped = new (data.constructor)(data.length);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcIdx = y * width + x;\n                const dstIdx = (height - 1 - y) * width + x;\n                flipped[dstIdx] = data[srcIdx];\n            }\n        }\n        return flipped;\n    }\n\n    /**\n     * Send format info to VS Code\n     * @param {number} width - Image width\n     * @param {number} height - Image height\n     * @param {number} channels - Number of channels\n     * @param {string} formatLabel - Format label\n     * @param {number} maxval - Maximum value\n     */\n    _postFormatInfo(width, height, channels, formatLabel, maxval) {\n        if (!this.vscode) return;\n        this.vscode.postMessage({\n            type: 'formatInfo',\n            value: {\n                width,\n                height,\n                compression: 'None',\n                predictor: 1,\n                photometricInterpretation: channels === 3 ? 2 : 1,\n                planarConfig: 1,\n                samplesPerPixel: channels,\n                bitsPerSample: maxval > 255 ? 16 : 8,\n                sampleFormat: 1, // Unsigned integer\n                formatLabel,\n                maxval,\n                formatType: 'ppm', // For per-format settings\n                isInitialLoad: this._isInitialLoad // Signal that this is the first load\n            }\n        });\n    }\n\n    /**\n     * Perform the initial render if it was deferred\n     * Called when format-specific settings have been applied\n     * @returns {ImageData|null} - The rendered image data, or null if no pending render\n     */\n    /**\n     * Perform deferred rendering using stored data and current settings\n     * @returns {ImageData|null} Rendered image data or null\n     */\n    performDeferredRender() {\n        if (!this._pendingRenderData) {\n            return null;\n        }\n\n        const { displayData, width, height, maxval, channels } = this._pendingRenderData;\n        this._pendingRenderData = null;\n        this._isInitialLoad = false;\n\n        // Now render with the correct format-specific settings\n        const imageData = this._toImageDataWithNormalization(displayData, width, height, maxval, channels);\n\n        // Force status refresh\n        this.vscode.postMessage({ type: 'refresh-status' });\n\n        return imageData;\n    }\n}", "// @ts-check\n\"use strict\";\nimport { NormalizationHelper, ImageRenderer, ImageStatsCalculator } from './normalization-helper.js';\n\n/**\n * @typedef {Object} RawImageData\n * @property {number} width\n * @property {number} height\n * @property {Uint8Array | Uint8ClampedArray | Uint16Array} data\n * @property {number} channels\n * @property {number} bitDepth\n * @property {number} maxValue\n * @property {boolean} isRgbaFormat - If true, data is RGBA format; if false, data is raw channel format\n * @property {ImageData} [originalImageData] - Original ImageData from getImageData for zero-copy fast path\n */\n\n/**\n * PNG Processor for TIFF Visualizer using UPNG.js\n * Supports proper uint16 PNG handling and grayscale/RGB channel detection\n */\nexport class PngProcessor {\n    /**\n     * @param {any} settingsManager\n     * @param {any} vscode\n     */\n    constructor(settingsManager, vscode) {\n        this.settingsManager = settingsManager;\n        this.vscode = vscode;\n        /** @type {RawImageData | null} */\n        this._lastRaw = null;\n        this._pendingRenderData = null; // Store data waiting for format-specific settings\n        this._isInitialLoad = true; // Track if this is the first render\n        this._cachedStats = undefined; // Cache for min/max stats (only used in stats mode)\n    }\n\n    /**\n     * Process PNG/JPEG file - uses native API for 8-bit PNGs and all JPEGs, UPNG for 16-bit PNGs\n     * Note: JPEG handling is included here since JPEGs are always 8-bit and use the same native Image API path\n     * @param {string} src - Source URI\n     * @returns {Promise<{canvas: HTMLCanvasElement, imageData: ImageData}>}\n     */\n    async processPng(src) {\n        // JPEG files always use native browser Image API (they don't support 16-bit)\n        const isJpeg = src.toLowerCase().includes('.jpg') || src.toLowerCase().includes('.jpeg');\n\n        if (isJpeg) {\n            return this._processWithNativeAPI(src);\n        }\n\n        // For PNG files, detect bit depth and choose appropriate loader\n        try {\n            // Invalidate stats cache for new image\n            this._cachedStats = undefined;\n\n            const response = await fetch(src);\n            const arrayBuffer = await response.arrayBuffer();\n\n            // Quick bit depth detection from PNG IHDR chunk (just reads byte 24)\n            const bitDepth = this._detectPngBitDepth(arrayBuffer);\n            // For 8-bit images, use native browser API for better performance\n            if (bitDepth === 8 || bitDepth === null) {\n                return this._processWithNativeAPI(src);\n            }\n\n\n            // Decode with UPNG.js\n            // @ts-ignore\n            const png = UPNG.decode(arrayBuffer);\n\n            /*\n            png = {\n                width: number,\n                height: number,\n                depth: 1 | 2 | 4 | 8 | 16,  // Bit depth!\n                ctype: 0 | 2 | 3 | 4 | 6,   // Color type\n                data: ArrayBuffer,           // Raw pixel data\n                tabs: {...}                  // Metadata chunks\n            }\n\n            Color types:\n            0 = Grayscale\n            2 = RGB\n            3 = Palette (we'll convert to RGB)\n            4 = Grayscale + Alpha\n            6 = RGBA\n            */\n\n            const width = png.width;\n            const height = png.height;\n            let pngBitDepth = png.depth;\n            const colorType = png.ctype;\n\n            // Determine channels\n            let channels;\n            switch (colorType) {\n                case 0: channels = 1; break; // Grayscale\n                case 2: channels = 3; break; // RGB\n                case 3: channels = 3; break; // Palette \u2192 RGB\n                case 4: channels = 2; break; // Gray + Alpha\n                case 6: channels = 4; break; // RGBA\n                default: channels = 3;\n            }\n\n            // Convert palette images to RGBA8\n            let rawData;\n            if (colorType === 3) {\n                // @ts-ignore\n                const rgba = UPNG.toRGBA8(png);\n                rawData = new Uint8Array(rgba[0]); // First frame\n                channels = 4;\n                pngBitDepth = 8;\n            } else {\n                // Use raw data - may be uint8 or uint16!\n                if (pngBitDepth === 16) {\n                    // PNG stores uint16 in big-endian format, need to swap bytes\n                    const uint8Data = new Uint8Array(png.data);\n                    const uint16Data = new Uint16Array(uint8Data.length / 2);\n\n                    // Swap bytes from big-endian to little-endian\n                    for (let i = 0; i < uint16Data.length; i++) {\n                        const byteIdx = i * 2;\n                        const highByte = uint8Data[byteIdx];     // MSB (big-endian)\n                        const lowByte = uint8Data[byteIdx + 1];  // LSB\n                        uint16Data[i] = (highByte << 8) | lowByte;\n                    }\n\n                    rawData = uint16Data;\n                } else {\n                    rawData = new Uint8Array(png.data);\n                }\n            }\n\n            // Store raw data\n            this._lastRaw = {\n                width,\n                height,\n                data: rawData,\n                channels,\n                bitDepth: pngBitDepth,\n                maxValue: pngBitDepth === 16 ? 65535 : 255,\n                isRgbaFormat: false  // UPNG path stores raw channel format\n            };\n\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n\n            // Send format info BEFORE rendering (for deferred rendering)\n            if (this._isInitialLoad) {\n                this._postFormatInfo(width, height, channels, bitDepth, 'PNG');\n                this._pendingRenderData = true; // Flag that _lastRaw is ready for deferred render\n                // Return placeholder\n                const placeholderImageData = new ImageData(width, height);\n                return { canvas, imageData: placeholderImageData };\n            }\n\n            // Non-initial loads - render immediately\n            this._postFormatInfo(width, height, channels, pngBitDepth, 'PNG');\n            const imageData = this._renderToImageData();\n            this.vscode.postMessage({ type: 'refresh-status' });\n            return { canvas, imageData };\n        } catch (error) {\n            console.error('UPNG.js processing failed, falling back to browser Image API:', error);\n            return this._processWithNativeAPI(src);\n        }\n    }\n\n    /**\n     * Process image using native browser Image API (for 8-bit PNGs and JPEGs)\n     * @param {string} src - Source URI\n     * @returns {Promise<{canvas: HTMLCanvasElement, imageData: ImageData}>}\n     */\n    async _processWithNativeAPI(src) {\n        const image = new Image();\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d', { willReadFrequently: true });\n\n        if (!ctx) {\n            throw new Error('Could not get canvas context');\n        }\n\n        return new Promise((resolve, reject) => {\n            image.onload = () => {\n                try {\n                    canvas.width = image.naturalWidth;\n                    canvas.height = image.naturalHeight;\n\n                    ctx.drawImage(image, 0, 0);\n                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                    const rawData = imageData.data;\n\n                    // Determine if image has alpha channel\n                    let hasAlpha = false;\n                    for (let i = 3; i < rawData.length; i += 4) {\n                        if (rawData[i] < 255) {\n                            hasAlpha = true;\n                            break;\n                        }\n                    }\n\n                    this._lastRaw = {\n                        width: canvas.width,\n                        height: canvas.height,\n                        data: rawData,\n                        channels: 4, // Native API always returns RGBA (4 channels)\n                        bitDepth: 8,\n                        maxValue: 255,\n                        isRgbaFormat: true,  // Fallback path stores RGBA format from getImageData\n                        originalImageData: imageData // Store for zero-copy fast path\n                    };\n\n                    const format = src.toLowerCase().includes('.png') ? 'PNG' :\n                        src.toLowerCase().includes('.jpg') || src.toLowerCase().includes('.jpeg') ? 'JPEG' :\n                            'Image';\n\n                    // Use deferred rendering for consistency with other formats\n                    // Send format info and return placeholder - actual rendering happens in performDeferredRender()\n                    this._postFormatInfo(canvas.width, canvas.height, this._lastRaw.channels, 8, format);\n                    this._pendingRenderData = true; // Flag that _lastRaw is ready for deferred render\n\n                    // Return placeholder\n                    const placeholderImageData = new ImageData(canvas.width, canvas.height);\n                    resolve({ canvas, imageData: placeholderImageData });\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            image.onerror = () => {\n                reject(new Error('Failed to load image'));\n            };\n\n            image.src = src;\n        });\n    }\n\n    /**\n     * Render raw image data to ImageData with gamma/brightness corrections\n     * @returns {ImageData}\n     */\n    _renderToImageData() {\n        if (!this._lastRaw) return new ImageData(1, 1);\n\n        const { width, height, data, channels, bitDepth, maxValue, originalImageData } = this._lastRaw;\n        const settings = this.settingsManager.settings;\n        const isFloat = false; // PNG is always integer\n\n        // Ultra-fast path: If we have the original ImageData from getImageData and no processing is needed, return it directly\n        // This is a zero-copy optimization for the common case: 8-bit PNG/JPEG with no normalization or effects\n        const isIdentity = NormalizationHelper.isIdentityTransformation(settings);\n        const isGammaMode = settings.normalization?.gammaMode || false;\n        const rgbAs24BitMode = settings.rgbAs24BitGrayscale && channels >= 3;\n\n        if (originalImageData &&\n            isGammaMode &&\n            isIdentity &&\n            !rgbAs24BitMode &&\n            bitDepth === 8) {\n            // Can use original ImageData directly - no processing needed\n            return originalImageData;\n        }\n\n        // Calculate stats if needed\n        let stats = this._cachedStats;\n        if (!stats && !isGammaMode) {\n            stats = ImageStatsCalculator.calculateIntegerStats(data, width, height, channels);\n            this._cachedStats = stats;\n        }\n\n        // For gamma mode, provide dummy stats (renderer uses full type range)\n        if (isGammaMode && !stats) {\n            stats = { min: 0, max: maxValue };\n        }\n\n        // Create options object\n        const options = {\n            rgbAs24BitGrayscale: settings.rgbAs24BitGrayscale && channels >= 3,\n            typeMax: maxValue\n        };\n\n        return ImageRenderer.render(\n            data,\n            width,\n            height,\n            channels,\n            isFloat,\n            stats,\n            settings,\n            options\n        );\n    }\n    /**\n     * Fallback gamma rendering for browser Image API path\n     * Re-render PNG with current settings (for real-time updates)\n     * @returns {ImageData | null}\n     */\n    renderPngWithSettings() {\n        if (!this._lastRaw) return null;\n        return this._renderToImageData();\n    }\n\n    /**\n     * Get color value at specific pixel coordinates\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @param {number} naturalWidth - Image width\n     * @param {number} naturalHeight - Image height\n     * @returns {string} Formatted color string\n     */\n    getColorAtPixel(x, y, naturalWidth, naturalHeight) {\n        if (!this._lastRaw) return '';\n        const { width, height, data, channels, bitDepth, maxValue } = this._lastRaw;\n        if (width !== naturalWidth || height !== naturalHeight) return '';\n\n        const pixelIdx = y * width + x;\n        const dataIdx = pixelIdx * channels;\n        const settings = this.settingsManager.settings;\n\n        if (dataIdx >= 0 && dataIdx < data.length) {\n            if (channels === 1) {\n                // Grayscale\n                const value = data[dataIdx];\n\n                // Check if normalized float mode is enabled\n                if (settings.normalizedFloatMode) {\n                    // Convert uint to normalized float (0-1)\n                    const normalized = value / maxValue;\n                    return normalized.toPrecision(4);\n                }\n\n                // Normal mode - show actual bit depth value\n                return value.toString();\n            } else if (channels === 2) {\n                // Grayscale + Alpha\n                const maxVal = bitDepth === 16 ? 65535 : 255;\n                const gray = data[dataIdx];\n                const alpha = data[dataIdx + 1];\n                return `${gray} \u03B1:${(alpha / maxVal).toFixed(2)}`;\n            } else if (channels === 3 || channels === 4) {\n                // RGB or RGBA\n                const r = data[dataIdx];\n                const g = data[dataIdx + 1];\n                const b = data[dataIdx + 2];\n\n                // If RGB as 24-bit grayscale is enabled, show combined value\n                if (settings.rgbAs24BitGrayscale && channels >= 3) {\n                    // Scale to 8-bit if needed\n                    const rByte = bitDepth === 16 ? Math.round(r / 257) : r;\n                    const gByte = bitDepth === 16 ? Math.round(g / 257) : g;\n                    const bByte = bitDepth === 16 ? Math.round(b / 257) : b;\n\n                    // Combine into 24-bit value\n                    const combined24bit = (rByte << 16) | (gByte << 8) | bByte;\n\n                    // Apply scale factor for display\n                    const scaleFactor = settings.scale24BitFactor || 1000;\n                    const scaledValue = (combined24bit / scaleFactor).toFixed(3);\n\n                    if (channels === 4) {\n                        const maxVal = bitDepth === 16 ? 65535 : 255;\n                        const a = data[dataIdx + 3];\n                        return `${scaledValue} \u03B1:${(a / maxVal).toFixed(2)}`;\n                    } else {\n                        return scaledValue;\n                    }\n                }\n\n                // Normal mode - show RGB values\n                if (channels === 3) {\n                    if (bitDepth === 16) {\n                        return `${r} ${g} ${b}`;\n                    } else {\n                        return `${r.toString().padStart(3, '0')} ${g.toString().padStart(3, '0')} ${b.toString().padStart(3, '0')}`;\n                    }\n                } else {\n                    // RGBA\n                    const maxVal = bitDepth === 16 ? 65535 : 255;\n                    const a = data[dataIdx + 3];\n                    if (bitDepth === 16) {\n                        return `${r} ${g} ${b} \u03B1:${(a / maxVal).toFixed(2)}`;\n                    } else {\n                        return `${r.toString().padStart(3, '0')} ${g.toString().padStart(3, '0')} ${b.toString().padStart(3, '0')} \u03B1:${(a / maxVal).toFixed(2)}`;\n                    }\n                }\n            }\n        }\n        return '';\n    }\n\n    /**\n     * Post format information to VS Code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} channels\n     * @param {number} bitDepth\n     * @param {string} formatLabel\n     */\n    _postFormatInfo(width, height, channels, bitDepth, formatLabel) {\n        if (!this.vscode) return;\n\n        // Determine format type: 'png' or 'jpg' based on format label\n        const formatType = formatLabel === 'JPEG' ? 'jpg' : 'png';\n\n        this.vscode.postMessage({\n            type: 'formatInfo',\n            value: {\n                width,\n                height,\n                compression: 'Deflate',\n                predictor: 1,\n                photometricInterpretation: channels >= 3 ? 2 : 1,\n                planarConfig: 1,\n                samplesPerPixel: channels,\n                bitsPerSample: bitDepth,\n                sampleFormat: 1, // Unsigned integer\n                formatLabel: `${formatLabel} (${bitDepth}-bit)`,\n                formatType: formatType, // 'png' or 'jpg' for independent settings\n                isInitialLoad: this._isInitialLoad // Signal that this is the first load\n            }\n        });\n    }\n\n    /**\n     * Perform the initial render if it was deferred\n     * Called when format-specific settings have been applied\n     * @returns {ImageData|null} - The rendered image data, or null if no pending render\n     */\n    performDeferredRender() {\n        if (!this._pendingRenderData || !this._lastRaw) {\n            return null;\n        }\n\n        this._pendingRenderData = null;\n        this._isInitialLoad = false;\n\n        // Render with the correct format-specific settings\n        const imageData = this._renderToImageData();\n\n        // Force status refresh\n        this.vscode.postMessage({ type: 'refresh-status' });\n\n        return imageData;\n    }\n\n    /**\n     * Detect PNG bit depth by reading the IHDR chunk\n     * @param {ArrayBuffer} arrayBuffer - PNG file data\n     * @returns {number|null} - Bit depth (1, 2, 4, 8, or 16), or null if detection fails\n     */\n    _detectPngBitDepth(arrayBuffer) {\n        try {\n            const data = new Uint8Array(arrayBuffer);\n\n            // PNG signature: 137 80 78 71 13 10 26 10\n            if (data.length < 8 || data[0] !== 137 || data[1] !== 80 || data[2] !== 78 || data[3] !== 71) {\n                console.warn('PNG: Invalid PNG signature');\n                return null;\n            }\n\n            // IHDR chunk starts at byte 8\n            // Structure: [length:4][type:4=\"IHDR\"][data:13][crc:4]\n            // IHDR data: [width:4][height:4][bitDepth:1][colorType:1][compression:1][filter:1][interlace:1]\n            const bitDepth = data[24]; // Bit depth is at offset 24\n\n            return bitDepth;\n        } catch (error) {\n            console.error('PNG: Failed to detect bit depth:', error);\n            return null;\n        }\n    }\n}\n", "// @ts-check\n\"use strict\";\n\n/**\n * Zoom Controller Module\n * Handles zoom, scale, pan, and viewport management\n */\nexport class ZoomController {\n\tconstructor(settingsManager, vscode) {\n\t\tthis.settingsManager = settingsManager;\n\t\tthis.vscode = vscode;\n\t\t\n\t\t// Initialize state from VS Code\n\t\tconst initialState = vscode.getState() || { scale: 'fit', offsetX: 0, offsetY: 0 };\n\t\tthis.scale = initialState.scale;\n\t\tthis.initialState = initialState;\n\t\t\n\t\t// DOM elements\n\t\tthis.container = document.body;\n\t\tthis.imageElement = null;\n\t\tthis.canvas = null;\n\t\tthis.hasLoadedImage = false;\n\t}\n\n\t/**\n\t * Set the image element reference\n\t * @param {HTMLElement} element\n\t */\n\tsetImageElement(element) {\n\t\tthis.imageElement = element;\n\t}\n\n\t/**\n\t * Set the canvas reference\n\t * @param {HTMLCanvasElement} canvas\n\t */\n\tsetCanvas(canvas) {\n\t\tthis.canvas = canvas;\n\t}\n\n\t/**\n\t * Mark that image has been loaded\n\t */\n\tsetImageLoaded() {\n\t\tthis.hasLoadedImage = true;\n\t}\n\n\t/**\n\t * Update scale with new value\n\t * @param {number|string} newScale\n\t */\n\tupdateScale(newScale) {\n\t\tif (!this.imageElement || !this.hasLoadedImage || !this.imageElement.parentElement) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst constants = this.settingsManager.constants;\n\t\tconst wasInFitMode = this.scale === 'fit';\n\n\t\tif (newScale === 'fit') {\n\t\t\tthis.scale = 'fit';\n\t\t\tthis.imageElement.classList.add('scale-to-fit');\n\t\t\tthis.imageElement.classList.remove('pixelated');\n\t\t\t// Clear inline sizing and transforms when returning to fit\n\t\t\tthis.imageElement.style.transform = '';\n\t\t\tthis.imageElement.style.transformOrigin = '';\n\t\t\tthis.imageElement.style.width = '';\n\t\t\tthis.imageElement.style.height = '';\n\t\t\tthis.imageElement.style.margin = '';\n\t\t\tthis.vscode.setState(undefined);\n\t\t} else {\n\t\t\tconst oldScale = this.scale;\n\t\t\tthis.scale = this._clamp(newScale, constants.MIN_SCALE, constants.MAX_SCALE);\n\t\t\tif (this.scale >= constants.PIXELATION_THRESHOLD) {\n\t\t\t\tthis.imageElement.classList.add('pixelated');\n\t\t\t} else {\n\t\t\t\tthis.imageElement.classList.remove('pixelated');\n\t\t\t}\n\n\t\t\t// Compute the image-space point under the viewport center before scaling\n\t\t\tconst canvas = /** @type {HTMLCanvasElement} */ (this.imageElement);\n\t\t\tconst naturalWidth = canvas.width;\n\t\t\tconst naturalHeight = canvas.height;\n\t\t\tconst prevScale = (wasInFitMode)\n\t\t\t\t? (canvas.clientWidth / naturalWidth)\n\t\t\t\t: /** @type {number} */ (oldScale);\n\n\t\t\t// Viewport center in document coordinates\n\t\t\tconst viewportCenterX = window.scrollX + this.container.clientWidth / 2;\n\t\t\tconst viewportCenterY = window.scrollY + this.container.clientHeight / 2;\n\t\t\t// Element top-left in document coordinates\n\t\t\tconst rectBefore = this.imageElement.getBoundingClientRect();\n\t\t\tconst elemLeftDoc = window.scrollX + rectBefore.left;\n\t\t\tconst elemTopDoc = window.scrollY + rectBefore.top;\n\t\t\t// Image-space center point\n\t\t\tconst centerXImage = (viewportCenterX - elemLeftDoc) / prevScale;\n\t\t\tconst centerYImage = (viewportCenterY - elemTopDoc) / prevScale;\n\n\t\t\t// Switch to layout-based scaling: remove fit class and set explicit size\n\t\t\tthis.imageElement.classList.remove('scale-to-fit');\n\t\t\tthis.imageElement.style.transform = '';\n\t\t\tthis.imageElement.style.transformOrigin = '';\n\t\t\tthis.imageElement.style.width = `${naturalWidth * this.scale}px`;\n\t\t\tthis.imageElement.style.height = `${naturalHeight * this.scale}px`;\n\n\t\t\t// Center when smaller than viewport, remove margins when scrollable\n\t\t\tconst canScrollX = this.container.scrollWidth > this.container.clientWidth + 1;\n\t\t\tconst canScrollY = this.container.scrollHeight > this.container.clientHeight + 1;\n\t\t\tthis.imageElement.style.marginLeft = canScrollX ? '0' : 'auto';\n\t\t\tthis.imageElement.style.marginRight = canScrollX ? '0' : 'auto';\n\t\t\tthis.imageElement.style.marginTop = canScrollY ? '0' : 'auto';\n\t\t\tthis.imageElement.style.marginBottom = canScrollY ? '0' : 'auto';\n\n\t\t\t// Recalculate element position after layout change\n\t\t\tconst rectAfter = this.imageElement.getBoundingClientRect();\n\t\t\tconst elemLeftDocAfter = window.scrollX + rectAfter.left;\n\t\t\tconst elemTopDocAfter = window.scrollY + rectAfter.top;\n\n\t\t\t// Calculate new scroll position to keep the same image point centered\n\t\t\tlet newScrollX = centerXImage * this.scale + elemLeftDocAfter - this.container.clientWidth / 2;\n\t\t\tlet newScrollY = centerYImage * this.scale + elemTopDocAfter - this.container.clientHeight / 2;\n\n\t\t\t// Clamp scroll positions to valid ranges\n\t\t\tconst maxScrollX = Math.max(0, this.container.scrollWidth - this.container.clientWidth);\n\t\t\tconst maxScrollY = Math.max(0, this.container.scrollHeight - this.container.clientHeight);\n\t\t\tnewScrollX = Math.min(Math.max(0, newScrollX), maxScrollX);\n\t\t\tnewScrollY = Math.min(Math.max(0, newScrollY), maxScrollY);\n\n\t\t\twindow.scrollTo(newScrollX, newScrollY);\n\n\t\t\tthis.vscode.setState({ scale: this.scale, offsetX: newScrollX, offsetY: newScrollY });\n\t\t}\n\n\t\tthis.vscode.postMessage({\n\t\t\ttype: 'zoom',\n\t\t\tvalue: this.scale\n\t\t});\n\t}\n\n\t/**\n\t * Zoom in to next level\n\t */\n\tzoomIn() {\n\t\tif (!this.imageElement || !this.hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.scale === 'fit') {\n\t\t\tthis.firstZoom();\n\t\t}\n\n\t\tconst zoomLevels = this.settingsManager.constants.ZOOM_LEVELS;\n\t\tlet i = 0;\n\t\tfor (; i < zoomLevels.length; ++i) {\n\t\t\tif (zoomLevels[i] > this.scale) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.updateScale(zoomLevels[i] || this.settingsManager.constants.MAX_SCALE);\n\t}\n\n\t/**\n\t * Zoom out to previous level\n\t */\n\tzoomOut() {\n\t\tif (!this.imageElement || !this.hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.scale === 'fit') {\n\t\t\tthis.firstZoom();\n\t\t}\n\n\t\tconst zoomLevels = this.settingsManager.constants.ZOOM_LEVELS;\n\t\tlet i = zoomLevels.length - 1;\n\t\tfor (; i >= 0; --i) {\n\t\t\tif (zoomLevels[i] < this.scale) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.updateScale(zoomLevels[i] || this.settingsManager.constants.MIN_SCALE);\n\t}\n\n\t/**\n\t * Calculate first zoom level based on current display size\n\t */\n\tfirstZoom() {\n\t\tif (!this.imageElement || !this.hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\t\t// For all image types, imageElement is the canvas.\n\t\t// The current scale is the ratio of its displayed size to its intrinsic size.\n\t\tconst canvas = /** @type {HTMLCanvasElement} */ (this.imageElement);\n\t\tthis.scale = canvas.clientWidth / canvas.width;\n\t\tthis.updateScale(this.scale);\n\t}\n\n\t/**\n\t * Reset zoom to fit\n\t */\n\tresetZoom() {\n\t\tthis.updateScale('fit');\n\t}\n\n\t/**\n\t * Handle mouse wheel events for zooming\n\t * @param {WheelEvent} e\n\t * @param {boolean} ctrlPressed\n\t * @param {boolean} altPressed\n\t */\n\thandleWheelZoom(e, ctrlPressed, altPressed) {\n\t\tif (!this.imageElement || !this.hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isScrollWheelKeyPressed = this.settingsManager.isMac ? altPressed : ctrlPressed;\n\t\tif (!isScrollWheelKeyPressed && !e.ctrlKey) { // pinching is reported as scroll wheel + ctrl\n\t\t\treturn;\n\t\t}\n\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\n\t\tif (this.scale === 'fit') {\n\t\t\tthis.firstZoom();\n\t\t}\n\n\t\tconst delta = e.deltaY > 0 ? 1 : -1;\n\t\tthis.updateScale(this.scale * (1 - delta * this.settingsManager.constants.SCALE_PINCH_FACTOR));\n\t}\n\n\t/**\n\t * Apply initial zoom and scroll position\n\t */\n\tapplyInitialZoom() {\n\t\tthis.updateScale(this.scale);\n\n\t\tif (this.initialState.scale !== 'fit') {\n\t\t\twindow.scrollTo(this.initialState.offsetX, this.initialState.offsetY);\n\t\t}\n\t}\n\n\t/**\n\t * Save current state\n\t */\n\tsaveState() {\n\t\tconst entry = this.vscode.getState();\n\t\tif (entry) {\n\t\t\tthis.vscode.setState(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Get current zoom state for image switching\n\t */\n\tgetCurrentState() {\n\t\treturn {\n\t\t\tscale: this.scale,\n\t\t\tx: window.scrollX,\n\t\t\ty: window.scrollY\n\t\t};\n\t}\n\n\t/**\n\t * Restore zoom state after image switching\n\t */\n\trestoreState(state) {\n\t\tif (state && state.scale !== undefined) {\n\t\t\tthis.updateScale(state.scale);\n\t\t\tif (state.x !== undefined && state.y !== undefined) {\n\t\t\t\t// Use setTimeout to ensure the new image is fully rendered\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\twindow.scrollTo(state.x, state.y);\n\t\t\t\t}, 50);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clamp a value between min and max\n\t * @private\n\t */\n\t_clamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n} ", "// @ts-check\n\"use strict\";\n\n/**\n * Mouse Handler Module\n * Handles mouse interactions, pixel reading, and cursor state\n */\nexport class MouseHandler {\n\tconstructor(settingsManager, vscode, tiffProcessor) {\n\t\tthis.settingsManager = settingsManager;\n\t\tthis.vscode = vscode;\n\t\tthis.tiffProcessor = tiffProcessor;\n\t\tthis.exrProcessor = null;\n\t\tthis.npyProcessor = null;\n\t\tthis.pfmProcessor = null;\n\t\tthis.ppmProcessor = null;\n\t\tthis.pngProcessor = null;\n\t\t\n\t\t// State\n\t\tthis.ctrlPressed = false;\n\t\tthis.altPressed = false;\n\t\tthis.isActive = false;\n\t\tthis.consumeClick = true;\n\t\t\n\t\t// DOM elements\n\t\tthis.container = document.body;\n\t\tthis.imageElement = null;\n\t\t\n\t\tthis._setupKeyboardListeners();\n\t}\n\n\t/**\n\t * Set the image element reference\n\t * @param {HTMLElement} element\n\t */\n\tsetImageElement(element) {\n\t\tthis.imageElement = element;\n\t}\n\n\tsetExrProcessor(proc) { this.exrProcessor = proc; }\n\tsetNpyProcessor(proc) { this.npyProcessor = proc; }\n\tsetPfmProcessor(proc) { this.pfmProcessor = proc; }\n\tsetPpmProcessor(proc) { this.ppmProcessor = proc; }\n\tsetPngProcessor(proc) { this.pngProcessor = proc; }\n\n\t/**\n\t * Set active state\n\t * @param {boolean} value\n\t */\n\tsetActive(value) {\n\t\tthis.isActive = value;\n\t\tif (value) {\n\t\t\tif (this.settingsManager.isMac ? this.altPressed : this.ctrlPressed) {\n\t\t\t\tthis.container.classList.remove('zoom-in');\n\t\t\t\tthis.container.classList.add('zoom-out');\n\t\t\t} else {\n\t\t\t\tthis.container.classList.remove('zoom-out');\n\t\t\t\tthis.container.classList.add('zoom-in');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.ctrlPressed = false;\n\t\t\tthis.altPressed = false;\n\t\t\tthis.container.classList.remove('zoom-out');\n\t\t\tthis.container.classList.remove('zoom-in');\n\t\t}\n\t}\n\n\t/**\n\t * Add mouse listeners to an element\n\t * @param {HTMLElement} element\n\t */\n\taddMouseListeners(element) {\n\t\telement.addEventListener('mouseenter', (e) => this._handleMouseEnter(e));\n\t\telement.addEventListener('mousemove', (e) => this._handleMouseMove(e));\n\t\telement.addEventListener('mouseleave', (e) => this._handleMouseLeave(e));\n\t}\n\n\t/**\n\t * Handle mouse enter event\n\t * @private\n\t */\n\t_handleMouseEnter(e) {\n\t\tif (!this.imageElement) return;\n\t\tconst pixelInfo = this._getPixelInfo(e);\n\t\tif (pixelInfo) {\n\t\t\tthis.vscode.postMessage({ type: 'pixelFocus', value: pixelInfo });\n\t\t} else {\n\t\t\tthis.vscode.postMessage({ type: 'pixelBlur' });\n\t\t}\n\t}\n\n\t/**\n\t * Handle mouse move event\n\t * @private\n\t */\n\t_handleMouseMove(e) {\n\t\tif (!this.imageElement) return;\n\t\tconst pixelInfo = this._getPixelInfo(e);\n\t\tif (pixelInfo) {\n\t\t\tthis.vscode.postMessage({ type: 'pixelFocus', value: pixelInfo });\n\t\t} else {\n\t\t\tthis.vscode.postMessage({ type: 'pixelBlur' });\n\t\t}\n\t}\n\n\t/**\n\t * Handle mouse leave event\n\t * @private\n\t */\n\t_handleMouseLeave(e) {\n\t\tthis.vscode.postMessage({\n\t\t\ttype: 'pixelBlur'\n\t\t});\n\t}\n\n\t/**\n\t * Get pixel information at mouse position\n\t * @private\n\t */\n\t_getPixelInfo(e) {\n\t\tif (!this.imageElement) return '';\n\t\t\n\t\tconst rect = this.imageElement.getBoundingClientRect();\n\t\tconst canvas = /** @type {HTMLCanvasElement} */ (this.imageElement);\n\t\tconst naturalWidth = canvas.width;\n\t\tconst naturalHeight = canvas.height;\n\t\t// Ignore when outside the element's content box\n\t\tif (\n\t\t\te.clientX < rect.left || e.clientX > rect.right ||\n\t\t\te.clientY < rect.top || e.clientY > rect.bottom ||\n\t\t\trect.width <= 0 || rect.height <= 0\n\t\t) {\n\t\t\treturn '';\n\t\t}\n\t\tconst ratioX = (e.clientX - rect.left) / rect.width;\n\t\tconst ratioY = (e.clientY - rect.top) / rect.height;\n\t\tlet x = Math.floor(ratioX * naturalWidth);\n\t\tlet y = Math.floor(ratioY * naturalHeight);\n\t\t// Clamp to valid pixel indices\n\t\tx = Math.min(Math.max(0, x), Math.max(0, naturalWidth - 1));\n\t\ty = Math.min(Math.max(0, y), Math.max(0, naturalHeight - 1));\n\t\tconst color = this._getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\n\t\treturn `${x}x${y} ${color}`;\n\t}\n\n\t/**\n\t * Apply gamma and brightness transformations to a pixel value\n\t * The correct order is: remove input gamma \u2192 apply exposure in linear space \u2192 apply output gamma\n\t * @private\n\t * @param {number} value - Normalized pixel value (0-1)\n\t * @returns {number} - Transformed value\n\t */\n\t_applyGammaBrightness(value) {\n\t\tconst gamma = this.settingsManager.settings.gamma || { in: 1.0, out: 1.0 };\n\t\tconst brightness = this.settingsManager.settings.brightness || { offset: 0 };\n\n\t\t// Step 1: Remove input gamma (linearize) - raise to gammaIn power\n\t\tlet linear = Math.pow(value, gamma.in);\n\n\t\t// Step 2: Apply exposure compensation in linear space (in stops: 2^stops)\n\t\tconst exposureStops = brightness.offset;\n\t\tlinear = linear * Math.pow(2, exposureStops);\n\n\t\t// Step 3: Apply output gamma - raise to 1/gammaOut power\n\t\tlet corrected = Math.pow(Math.max(0, linear), 1.0 / gamma.out);\n\n\t\t// Note: Do NOT clamp here - allow values outside [0,1] for float images\n\t\treturn corrected;\n\t}\n\n\t/**\n\t * Get color at specific pixel coordinates\n\t * @private\n\t */\n\t_getColorAtPixel(x, y, naturalWidth, naturalHeight) {\n\t\t// Check if we should show modified values\n\t\tconst showModified = this.settingsManager.settings.colorPickerShowModified || false;\n\n\t\t// Try TIFF processor first\n\t\tif (this.tiffProcessor) {\n\t\t\tconst tiffColor = this.tiffProcessor.getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\tif (tiffColor) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\t// Apply gamma and brightness to TIFF values\n\t\t\t\t\tconst values = this._parseTiffColor(tiffColor);\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\tconst transformed = values.map(v => this._applyGammaBrightness(v));\n\t\t\t\t\t\treturn this._formatColorValues(transformed, values.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn tiffColor;\n\t\t\t}\n\t\t}\n\n\t\t// Try EXR processor for HDR images\n\t\tif (this.exrProcessor && this.exrProcessor.rawExrData) {\n\t\t\tconst pixelValues = this.exrProcessor.getPixelValue(x, y);\n\t\t\tif (pixelValues) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\t// Apply gamma and brightness to HDR values (but NOT to alpha)\n\t\t\t\t\tconst transformed = [];\n\t\t\t\t\tfor (let i = 0; i < pixelValues.length; i++) {\n\t\t\t\t\t\tconst v = pixelValues[i];\n\t\t\t\t\t\tif (isNaN(v) || !isFinite(v)) {\n\t\t\t\t\t\t\ttransformed.push(v);\n\t\t\t\t\t\t} else if (i === 3 && pixelValues.length === 4) {\n\t\t\t\t\t\t\t// Alpha channel: do NOT apply gamma/brightness\n\t\t\t\t\t\t\ttransformed.push(v);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// RGB channels: apply gamma/brightness\n\t\t\t\t\t\t\ttransformed.push(this._applyGammaBrightness(v));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Format HDR values with more precision\n\t\t\t\t\tif (transformed.length === 1) {\n\t\t\t\t\t\t// Grayscale\n\t\t\t\t\t\treturn transformed[0].toFixed(6);\n\t\t\t\t\t} else if (transformed.length === 3) {\n\t\t\t\t\t\t// RGB\n\t\t\t\t\t\treturn `${transformed[0].toFixed(6)} ${transformed[1].toFixed(6)} ${transformed[2].toFixed(6)}`;\n\t\t\t\t\t} else if (transformed.length === 4) {\n\t\t\t\t\t\t// RGBA - alpha is shown unmodified\n\t\t\t\t\t\treturn `${transformed[0].toFixed(6)} ${transformed[1].toFixed(6)} ${transformed[2].toFixed(6)} \u03B1:${transformed[3].toFixed(6)}`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Show original values\n\t\t\t\t\tif (pixelValues.length === 1) {\n\t\t\t\t\t\treturn pixelValues[0].toFixed(6);\n\t\t\t\t\t} else if (pixelValues.length === 3) {\n\t\t\t\t\t\treturn `${pixelValues[0].toFixed(6)} ${pixelValues[1].toFixed(6)} ${pixelValues[2].toFixed(6)}`;\n\t\t\t\t\t} else if (pixelValues.length === 4) {\n\t\t\t\t\t\t// RGBA - consistent format with \u03B1: prefix for alpha\n\t\t\t\t\t\treturn `${pixelValues[0].toFixed(6)} ${pixelValues[1].toFixed(6)} ${pixelValues[2].toFixed(6)} \u03B1:${pixelValues[3].toFixed(6)}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try NPY/PFM/PPM processors for other image formats\n\t\tif (this.npyProcessor) {\n\t\t\tconst v = this.npyProcessor.getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\tif (v) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\tconst values = this._parseFloatColor(v);\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\tconst transformed = values.map(val => this._applyGammaBrightness(val));\n\t\t\t\t\t\treturn this._formatColorValues(transformed, values.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\tif (this.pfmProcessor) {\n\t\t\tconst v = this.pfmProcessor.getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\tif (v) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\tconst values = this._parseFloatColor(v);\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\tconst transformed = values.map(val => this._applyGammaBrightness(val));\n\t\t\t\t\t\treturn this._formatColorValues(transformed, values.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\tif (this.ppmProcessor) {\n\t\t\tconst v = this.ppmProcessor.getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\tif (v) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\tconst values = this._parseIntColor(v);\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\t// For PPM, normalize to 0-1, apply transforms, then scale back\n\t\t\t\t\t\tconst normalized = values.map(val => val / 255);\n\t\t\t\t\t\tconst transformed = normalized.map(val => this._applyGammaBrightness(val));\n\t\t\t\t\t\tconst scaled = transformed.map(val => Math.round(Math.max(0, Math.min(1, val)) * 255));\n\t\t\t\t\t\treturn this._formatColorValues(scaled, values.length, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\tif (this.pngProcessor) {\n\t\t\tconst v = this.pngProcessor.getColorAtPixel(x, y, naturalWidth, naturalHeight);\n\t\t\tif (v) {\n\t\t\t\tif (showModified) {\n\t\t\t\t\tconst values = this._parseIntColor(v);\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\t// For PNG, normalize to 0-1, apply transforms, then scale back\n\t\t\t\t\t\tconst normalized = values.map(val => val / 255);\n\t\t\t\t\t\tconst transformed = normalized.map(val => this._applyGammaBrightness(val));\n\t\t\t\t\t\tconst scaled = transformed.map(val => Math.round(Math.max(0, Math.min(1, val)) * 255));\n\t\t\t\t\t\treturn this._formatColorValues(scaled, values.length, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to canvas pixel reading for standard images\n\t\tif (this.imageElement) {\n\t\t\tconst canvas = /** @type {HTMLCanvasElement} */ (this.imageElement);\n\t\t\tconst ctx = canvas.getContext('2d', { willReadFrequently: true });\n\t\t\tif (ctx) {\n\t\t\t\tconst pixel = ctx.getImageData(x, y, 1, 1).data;\n\t\t\t\tif (showModified) {\n\t\t\t\t\t// Normalize to 0-1, apply transforms, then scale back to 0-255\n\t\t\t\t\tconst normalized = Array.from(pixel.slice(0, 3)).map(v => v / 255);\n\t\t\t\t\tconst transformed = normalized.map(val => this._applyGammaBrightness(val));\n\t\t\t\t\tconst scaled = transformed.map(val => Math.round(Math.max(0, Math.min(1, val)) * 255));\n\t\t\t\t\treturn `${scaled[0].toString().padStart(3, '0')} ${scaled[1].toString().padStart(3, '0')} ${scaled[2].toString().padStart(3, '0')}`;\n\t\t\t\t}\n\t\t\t\treturn `${pixel[0].toString().padStart(3, '0')} ${pixel[1].toString().padStart(3, '0')} ${pixel[2].toString().padStart(3, '0')}`;\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Parse TIFF color string to array of values\n\t * @private\n\t * @param {string} colorStr - Color string from TIFF processor\n\t * @returns {Array<number>|null} - Array of numeric values or null\n\t */\n\t_parseTiffColor(colorStr) {\n\t\ttry {\n\t\t\t// TIFF colors are space-separated numbers\n\t\t\tconst parts = colorStr.trim().split(/\\s+/);\n\t\t\tconst values = parts.map(p => {\n\t\t\t\tconst num = parseFloat(p);\n\t\t\t\treturn isNaN(num) ? null : num;\n\t\t\t});\n\t\t\treturn values.every(v => v !== null) ? values : null;\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse float color string to array of values (space-separated floats or NaN/Inf)\n\t * Handles formats like: \"1.234 2.345 3.456\" or \"1.234 2.345 3.456 A:4.567\" or \"NaN Inf -Inf\"\n\t * @private\n\t * @param {string} colorStr - Color string\n\t * @returns {Array<number>|null} - Array of numeric values or null\n\t */\n\t_parseFloatColor(colorStr) {\n\t\ttry {\n\t\t\t// Float colors are space-separated numbers (possibly with A: prefix for alpha)\n\t\t\tconst parts = colorStr.trim().split(/\\s+/);\n\t\t\tconst values = parts.map(p => {\n\t\t\t\t// Remove \"A:\" prefix if present\n\t\t\t\tconst cleanPart = p.replace('A:', '');\n\t\t\t\t// Handle special values\n\t\t\t\tif (cleanPart === 'NaN') return NaN;\n\t\t\t\tif (cleanPart === 'Inf') return Infinity;\n\t\t\t\tif (cleanPart === '-Inf') return -Infinity;\n\t\t\t\tconst num = parseFloat(cleanPart);\n\t\t\t\treturn isNaN(num) && cleanPart !== 'NaN' ? null : num;\n\t\t\t});\n\t\t\treturn values.every(v => v !== null) ? values : null;\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse integer color string to array of values (0-255)\n\t * @private\n\t * @param {string} colorStr - Color string like \"255 128 64\"\n\t * @returns {Array<number>|null} - Array of numeric values or null\n\t */\n\t_parseIntColor(colorStr) {\n\t\ttry {\n\t\t\t// Integer colors are padded 3-digit numbers like \"255 128 064\"\n\t\t\tconst parts = colorStr.trim().split(/\\s+/);\n\t\t\tconst values = parts.map(p => {\n\t\t\t\tconst num = parseInt(p, 10);\n\t\t\t\treturn isNaN(num) ? null : num;\n\t\t\t});\n\t\t\treturn values.every(v => v !== null) ? values : null;\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Format color values back to string\n\t * Handles both integer and float formats consistently\n\t * @private\n\t * @param {Array<number>} values - Color values\n\t * @param {number} count - Number of values (for formatting)\n\t * @param {boolean} [asIntegers] - If true, format as padded integers\n\t * @returns {string} - Formatted color string\n\t */\n\t_formatColorValues(values, count, asIntegers = false) {\n\t\tconst formatted = values.slice(0, count).map((v, idx) => {\n\t\t\tif (asIntegers) {\n\t\t\t\treturn Math.round(v).toString().padStart(3, '0');\n\t\t\t} else {\n\t\t\t\t// Float format with appropriate precision\n\t\t\t\treturn v.toFixed(6);\n\t\t\t}\n\t\t});\n\n\t\t// Add alpha label if we have 4 values (RGBA)\n\t\tif (count === 4) {\n\t\t\treturn `${formatted[0]} ${formatted[1]} ${formatted[2]} \u03B1:${formatted[3]}`;\n\t\t}\n\t\treturn formatted.join(' ');\n\t}\n\n\t/**\n\t * Setup keyboard event listeners\n\t * @private\n\t */\n\t_setupKeyboardListeners() {\n\t\twindow.addEventListener('keydown', (e) => this._handleKeyDown(e));\n\t\twindow.addEventListener('keyup', (e) => this._handleKeyUp(e));\n\t\twindow.addEventListener('blur', () => this._handleBlur());\n\t}\n\n\t/**\n\t * Handle key down events\n\t * @private\n\t */\n\t_handleKeyDown(e) {\n\t\tif (!this.imageElement) return;\n\n\t\tif (e.key === 'Control') {\n\t\t\tthis.ctrlPressed = true;\n\t\t} else if (e.key === 'Alt') {\n\t\t\tthis.altPressed = true;\n\t\t}\n\n\t\tthis._updateCursorState();\n\t}\n\n\t/**\n\t * Handle key up events\n\t * @private\n\t */\n\t_handleKeyUp(e) {\n\t\tif (!this.imageElement) return;\n\n\t\tif (e.key === 'Control') {\n\t\t\tthis.ctrlPressed = false;\n\t\t} else if (e.key === 'Alt') {\n\t\t\tthis.altPressed = false;\n\t\t}\n\n\t\tthis._updateCursorState();\n\t}\n\n\t/**\n\t * Handle window blur (lost focus)\n\t * @private\n\t */\n\t_handleBlur() {\n\t\tthis.ctrlPressed = false;\n\t\tthis.altPressed = false;\n\t\tthis._updateCursorState();\n\t}\n\n\t/**\n\t * Update cursor state based on key presses\n\t * @private\n\t */\n\t_updateCursorState() {\n\t\tif (!this.isActive) return;\n\n\t\tif (this.settingsManager.isMac ? this.altPressed : this.ctrlPressed) {\n\t\t\tthis.container.classList.remove('zoom-in');\n\t\t\tthis.container.classList.add('zoom-out');\n\t\t} else {\n\t\t\tthis.container.classList.remove('zoom-out');\n\t\t\tthis.container.classList.add('zoom-in');\n\t\t}\n\t}\n\n\t/**\n\t * Get current keyboard state\n\t */\n\tgetKeyboardState() {\n\t\treturn {\n\t\t\tctrlPressed: this.ctrlPressed,\n\t\t\taltPressed: this.altPressed\n\t\t};\n\t}\n} ", "// @ts-check\n\"use strict\";\n\n/**\n * Histogram Overlay Module\n * Provides interactive histogram visualization for images\n */\nexport class HistogramOverlay {\n\tconstructor(settingsManager, vscode) {\n\t\tthis.settingsManager = settingsManager;\n\t\tthis.vscode = vscode;\n\n\t\tthis.overlay = null;\n\t\tthis.canvas = null;\n\t\tthis.ctx = null;\n\t\tthis.isVisible = false;\n\t\tthis.histogramData = null;\n\t\tthis.scaleMode = 'linear'; // 'linear' or 'log'\n\t\tthis.channelMode = 'combined'; // 'combined', 'separate', or 'luminance'\n\n\t\t// Histogram computation settings\n\t\tthis.numBins = 256;\n\n\t\t// UI state\n\t\tthis.isDragging = false;\n\t\tthis.dragOffset = { x: 0, y: 0 };\n\t\tthis.hoveredBin = -1;\n\n\t\tthis.createOverlay();\n\t}\n\n\t/**\n\t * Create the histogram overlay DOM structure\n\t */\n\tcreateOverlay() {\n\t\tthis.overlay = document.createElement('div');\n\t\tthis.overlay.className = 'histogram-overlay';\n\t\tthis.overlay.style.display = 'none';\n\n\t\t// Header with controls\n\t\tconst header = document.createElement('div');\n\t\theader.className = 'histogram-header';\n\n\t\tconst title = document.createElement('div');\n\t\ttitle.className = 'histogram-title';\n\t\ttitle.textContent = 'Histogram';\n\n\t\t// Scale mode toggle\n\t\tconst scaleToggle = document.createElement('button');\n\t\tscaleToggle.className = 'histogram-button';\n\t\tscaleToggle.textContent = 'Linear Mode';\n\t\tscaleToggle.title = 'Toggle Linear/Log scale';\n\t\tscaleToggle.onclick = () => this.toggleScaleMode(scaleToggle);\n\n\t\t// Close button\n\t\tconst closeBtn = document.createElement('button');\n\t\tcloseBtn.className = 'histogram-close';\n\t\tcloseBtn.textContent = '\u00D7';\n\t\tcloseBtn.title = 'Close histogram';\n\t\tcloseBtn.onclick = () => this.hide();\n\n\t\theader.appendChild(title);\n\t\theader.appendChild(scaleToggle);\n\t\theader.appendChild(closeBtn);\n\n\t\t// Canvas for histogram\n\t\tthis.canvas = document.createElement('canvas');\n\t\tthis.canvas.className = 'histogram-canvas';\n\t\tthis.canvas.width = 300;\n\t\tthis.canvas.height = 150;\n\t\tthis.ctx = this.canvas.getContext('2d');\n\n\t\t// Add mouse event listeners for hover effect\n\t\tthis.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n\t\tthis.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());\n\n\t\t// Min/Max labels container\n\t\tconst labels = document.createElement('div');\n\t\tlabels.className = 'histogram-labels';\n\t\tlabels.style.display = 'flex';\n\t\tlabels.style.justifyContent = 'space-between';\n\t\tlabels.style.padding = '0 5px';\n\t\tlabels.style.fontSize = '10px';\n\t\tlabels.style.color = '#cccccc';\n\t\tlabels.style.marginTop = '2px';\n\n\t\tthis.minLabel = document.createElement('span');\n\t\tthis.minLabel.textContent = '0';\n\t\tthis.maxLabel = document.createElement('span');\n\t\tthis.maxLabel.textContent = '255';\n\n\t\tlabels.appendChild(this.minLabel);\n\t\tlabels.appendChild(this.maxLabel);\n\n\t\t// Stats display\n\t\tconst stats = document.createElement('div');\n\t\tstats.className = 'histogram-stats';\n\t\tstats.id = 'histogram-stats';\n\n\t\t// Tooltip\n\t\tthis.tooltip = document.createElement('div');\n\t\tthis.tooltip.className = 'histogram-tooltip';\n\t\tthis.tooltip.style.position = 'absolute';\n\t\tthis.tooltip.style.display = 'none';\n\t\tthis.tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n\t\tthis.tooltip.style.color = 'white';\n\t\tthis.tooltip.style.padding = '4px 8px';\n\t\tthis.tooltip.style.borderRadius = '4px';\n\t\tthis.tooltip.style.fontSize = '11px';\n\t\tthis.tooltip.style.pointerEvents = 'none';\n\t\tthis.tooltip.style.zIndex = '1000';\n\n\t\tthis.overlay.appendChild(header);\n\t\tthis.overlay.appendChild(this.canvas);\n\t\tthis.overlay.appendChild(labels);\n\t\tthis.overlay.appendChild(stats);\n\t\tthis.overlay.appendChild(this.tooltip);\n\n\t\t// Make draggable\n\t\theader.style.cursor = 'move';\n\t\theader.onmousedown = (e) => this.startDrag(e);\n\n\t\tdocument.body.appendChild(this.overlay);\n\t}\n\n\t/**\n\t * Handle mouse move over canvas\n\t */\n\thandleMouseMove(e) {\n\t\tif (!this.histogramData) return;\n\n\t\tconst rect = this.canvas.getBoundingClientRect();\n\t\tconst scaleX = this.canvas.width / rect.width;\n\t\tconst x = (e.clientX - rect.left) * scaleX;\n\t\tconst width = this.canvas.width;\n\t\tconst padding = 5;\n\t\tconst graphWidth = width - 2 * padding;\n\n\t\t// Calculate bin index\n\t\t// x = padding + binIndex * binWidth\n\t\t// binIndex = (x - padding) / binWidth\n\t\tconst binWidth = graphWidth / this.numBins;\n\t\tlet binIndex = Math.floor((x - padding) / binWidth);\n\n\t\t// Clamp bin index\n\t\tbinIndex = Math.max(0, Math.min(binIndex, this.numBins - 1));\n\n\t\tif (this.hoveredBin !== binIndex) {\n\t\t\tthis.hoveredBin = binIndex;\n\t\t\tthis.render();\n\t\t}\n\n\t\t// Update tooltip\n\t\tthis.updateTooltip(e.clientX, e.clientY, binIndex);\n\t}\n\n\t/**\n\t * Handle mouse leave canvas\n\t */\n\thandleMouseLeave() {\n\t\tthis.hoveredBin = -1;\n\t\tthis.tooltip.style.display = 'none';\n\t\tthis.render();\n\t}\n\n\t/**\n\t * Update tooltip content and position\n\t */\n\tupdateTooltip(clientX, clientY, binIndex) {\n\t\tif (!this.histogramData || binIndex < 0) return;\n\n\t\tconst rCount = this.histogramData.r[binIndex];\n\t\tconst gCount = this.histogramData.g[binIndex];\n\t\tconst bCount = this.histogramData.b[binIndex];\n\t\tconst lumCount = this.histogramData.luminance[binIndex];\n\n\t\tlet content = `<strong>Value: ${binIndex}</strong><br>`;\n\n\t\tif (this.channelMode === 'combined' || this.channelMode === 'separate') {\n\t\t\tcontent += `<span style=\"color: #ff8888\">R: ${rCount.toLocaleString()}</span><br>`;\n\t\t\tcontent += `<span style=\"color: #88ff88\">G: ${gCount.toLocaleString()}</span><br>`;\n\t\t\tcontent += `<span style=\"color: #8888ff\">B: ${bCount.toLocaleString()}</span>`;\n\t\t} else {\n\t\t\tcontent += `Count: ${lumCount.toLocaleString()}`;\n\t\t}\n\n\t\tthis.tooltip.innerHTML = content;\n\t\tthis.tooltip.style.display = 'block';\n\n\t\t// Position tooltip near mouse but keep within viewport\n\t\tconst overlayRect = this.overlay.getBoundingClientRect();\n\t\tconst tooltipX = clientX - overlayRect.left + 10;\n\t\tconst tooltipY = clientY - overlayRect.top + 10;\n\n\t\tthis.tooltip.style.left = `${tooltipX}px`;\n\t\tthis.tooltip.style.top = `${tooltipY}px`;\n\t}\n\n\t/**\n\t * Show the histogram overlay\n\t */\n\tshow() {\n\t\tthis.isVisible = true;\n\t\tthis.overlay.style.display = 'flex';\n\t\t// Trigger computation if we have image data\n\t\tthis.vscode.postMessage({ type: 'requestHistogram' });\n\t}\n\n\t/**\n\t * Hide the histogram overlay\n\t */\n\thide() {\n\t\tthis.isVisible = false;\n\t\tthis.overlay.style.display = 'none';\n\t\tthis.vscode.postMessage({ type: 'histogramClosed' });\n\t}\n\n\t/**\n\t * Toggle histogram visibility\n\t */\n\ttoggle() {\n\t\tif (this.isVisible) {\n\t\t\tthis.hide();\n\t\t} else {\n\t\t\tthis.show();\n\t\t}\n\t}\n\n\t/**\n\t * Toggle between linear and log scale\n\t */\n\ttoggleScaleMode(button) {\n\t\tthis.scaleMode = this.scaleMode === 'linear' ? 'log' : 'linear';\n\t\tbutton.textContent = this.scaleMode === 'linear' ? 'Linear Mode' : 'Log Mode';\n\t\tthis.render();\n\t}\n\n\t/**\n\t * Compute histogram from image data\n\t * @param {ImageData} imageData - Canvas ImageData object\n\t */\n\tcomputeHistogram(imageData) {\n\t\tif (!imageData) return null;\n\n\t\tconst data = imageData.data;\n\t\tconst width = imageData.width;\n\t\tconst height = imageData.height;\n\t\tconst numPixels = width * height;\n\n\t\t// Initialize bins\n\t\tconst histR = new Array(this.numBins).fill(0);\n\t\tconst histG = new Array(this.numBins).fill(0);\n\t\tconst histB = new Array(this.numBins).fill(0);\n\t\tconst histLum = new Array(this.numBins).fill(0);\n\n\t\t// Compute histogram\n\t\tfor (let i = 0; i < data.length; i += 4) {\n\t\t\tconst r = data[i];\n\t\t\tconst g = data[i + 1];\n\t\t\tconst b = data[i + 2];\n\t\t\tconst a = data[i + 3];\n\n\t\t\t// Skip fully transparent pixels\n\t\t\tif (a === 0) continue;\n\n\t\t\thistR[r]++;\n\t\t\thistG[g]++;\n\t\t\thistB[b]++;\n\n\t\t\t// Compute luminance (standard weights for RGB)\n\t\t\tconst lum = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);\n\t\t\thistLum[lum]++;\n\t\t}\n\n\t\t// Compute statistics\n\t\tconst stats = this.computeStats(data);\n\n\t\treturn {\n\t\t\tr: histR,\n\t\t\tg: histG,\n\t\t\tb: histB,\n\t\t\tluminance: histLum,\n\t\t\tstats: stats,\n\t\t\tnumPixels: numPixels\n\t\t};\n\t}\n\n\t/**\n\t * Compute statistics from raw pixel data\n\t */\n\tcomputeStats(data) {\n\t\tlet minR = 255, maxR = 0, sumR = 0;\n\t\tlet minG = 255, maxG = 0, sumG = 0;\n\t\tlet minB = 255, maxB = 0, sumB = 0;\n\t\tlet count = 0;\n\n\t\tfor (let i = 0; i < data.length; i += 4) {\n\t\t\tconst a = data[i + 3];\n\t\t\tif (a === 0) continue; // Skip transparent pixels\n\n\t\t\tconst r = data[i];\n\t\t\tconst g = data[i + 1];\n\t\t\tconst b = data[i + 2];\n\n\t\t\tminR = Math.min(minR, r);\n\t\t\tmaxR = Math.max(maxR, r);\n\t\t\tsumR += r;\n\n\t\t\tminG = Math.min(minG, g);\n\t\t\tmaxG = Math.max(maxG, g);\n\t\t\tsumG += g;\n\n\t\t\tminB = Math.min(minB, b);\n\t\t\tmaxB = Math.max(maxB, b);\n\t\t\tsumB += b;\n\n\t\t\tcount++;\n\t\t}\n\n\t\treturn {\n\t\t\tr: { min: minR, max: maxR, mean: sumR / count },\n\t\t\tg: { min: minG, max: maxG, mean: sumG / count },\n\t\t\tb: { min: minB, max: maxB, mean: sumB / count }\n\t\t};\n\t}\n\n\t/**\n\t * Update histogram with new data\n\t */\n\tupdate(imageData) {\n\t\tthis.histogramData = this.computeHistogram(imageData);\n\t\tif (this.isVisible) {\n\t\t\tthis.render();\n\t\t}\n\t}\n\n\t/**\n\t * Render the histogram to canvas\n\t */\n\trender() {\n\t\tif (!this.histogramData || !this.ctx) return;\n\n\t\tconst width = this.canvas.width;\n\t\tconst height = this.canvas.height;\n\t\tconst padding = 5;\n\t\tconst graphHeight = height - 2 * padding;\n\t\tconst graphWidth = width - 2 * padding;\n\n\t\t// Clear canvas\n\t\tthis.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--vscode-editor-background') || '#1e1e1e';\n\t\tthis.ctx.fillRect(0, 0, width, height);\n\n\t\t// Determine which histogram to draw\n\t\tlet histograms = [];\n\t\tlet colors = [];\n\n\t\tif (this.channelMode === 'combined') {\n\t\t\t// Combined RGB histogram\n\t\t\thistograms = [this.histogramData.r, this.histogramData.g, this.histogramData.b];\n\t\t\tcolors = ['rgba(255, 100, 100, 0.5)', 'rgba(100, 255, 100, 0.5)', 'rgba(100, 100, 255, 0.5)'];\n\t\t} else if (this.channelMode === 'separate') {\n\t\t\t// Separate RGB histograms (stacked)\n\t\t\thistograms = [this.histogramData.r, this.histogramData.g, this.histogramData.b];\n\t\t\tcolors = ['rgba(255, 50, 50, 0.7)', 'rgba(50, 255, 50, 0.7)', 'rgba(50, 50, 255, 0.7)'];\n\t\t} else {\n\t\t\t// Luminance only\n\t\t\thistograms = [this.histogramData.luminance];\n\t\t\tcolors = ['rgba(200, 200, 200, 0.8)'];\n\t\t}\n\n\t\t// Find max value for scaling\n\t\tlet maxValue = 0;\n\t\tfor (const hist of histograms) {\n\t\t\tfor (let i = 0; i < hist.length; i++) {\n\t\t\t\tmaxValue = Math.max(maxValue, hist[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Apply log scale if needed\n\t\tconst scaleValue = (val) => {\n\t\t\tif (this.scaleMode === 'log') {\n\t\t\t\treturn val > 0 ? Math.log10(val + 1) : 0;\n\t\t\t}\n\t\t\treturn val;\n\t\t};\n\n\t\tconst scaledMax = scaleValue(maxValue);\n\n\t\t// Draw histograms\n\t\tconst binWidth = graphWidth / this.numBins;\n\n\t\tfor (let h = 0; h < histograms.length; h++) {\n\t\t\tconst hist = histograms[h];\n\t\t\tconst color = colors[h];\n\n\t\t\tthis.ctx.fillStyle = color;\n\t\t\tthis.ctx.beginPath();\n\n\t\t\tfor (let i = 0; i < this.numBins; i++) {\n\t\t\t\tconst x = padding + i * binWidth;\n\t\t\t\tconst scaledValue = scaleValue(hist[i]);\n\t\t\t\tconst barHeight = scaledMax > 0 ? (scaledValue / scaledMax) * graphHeight : 0;\n\t\t\t\tconst y = height - padding - barHeight;\n\n\t\t\t\tthis.ctx.fillRect(x, y, Math.max(1, binWidth - 0.5), barHeight);\n\t\t\t}\n\t\t}\n\n\t\t// Highlight hovered bin\n\t\tif (this.hoveredBin >= 0 && this.hoveredBin < this.numBins) {\n\t\t\tconst x = padding + this.hoveredBin * binWidth;\n\n\t\t\t// Draw a brighter highlight over the hovered bin\n\t\t\tthis.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n\t\t\tthis.ctx.fillRect(x, padding, Math.max(1, binWidth - 0.5), graphHeight);\n\n\t\t\t// Draw a vertical line indicator\n\t\t\tthis.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n\t\t\tthis.ctx.lineWidth = 1;\n\t\t\tthis.ctx.beginPath();\n\t\t\tthis.ctx.moveTo(x + binWidth / 2, padding);\n\t\t\tthis.ctx.lineTo(x + binWidth / 2, height - padding);\n\t\t\tthis.ctx.stroke();\n\t\t}\n\n\t\t// Draw border\n\t\tthis.ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--vscode-panel-border') || '#454545';\n\t\tthis.ctx.lineWidth = 1;\n\t\tthis.ctx.strokeRect(padding, padding, graphWidth, graphHeight);\n\n\t\t// Update stats display\n\t\tthis.updateStatsDisplay();\n\t}\n\n\t/**\n\t * Update statistics display\n\t */\n\tupdateStatsDisplay() {\n\t\tif (!this.histogramData) return;\n\n\t\tconst statsEl = document.getElementById('histogram-stats');\n\t\tif (!statsEl) return;\n\n\t\tconst stats = this.histogramData.stats;\n\n\t\t// Check if image is grayscale (all channels equal)\n\t\tconst isGrayscale = stats.r.min === stats.g.min && stats.g.min === stats.b.min &&\n\t\t\tstats.r.max === stats.g.max && stats.g.max === stats.b.max;\n\n\t\tif (isGrayscale || this.channelMode === 'luminance') {\n\t\t\t// Show single channel stats\n\t\t\tconst s = stats.r;\n\t\t\tstatsEl.innerHTML = `\n\t\t\t\t<span>Min: ${s.min}</span>\n\t\t\t\t<span>Max: ${s.max}</span>\n\t\t\t\t<span>Mean: ${s.mean.toFixed(1)}</span>\n\t\t\t`;\n\t\t} else {\n\t\t\t// Show RGB stats\n\t\t\tstatsEl.innerHTML = `\n\t\t\t\t<span style=\"color: #ff6666;\">R: ${stats.r.min}-${stats.r.max} (${stats.r.mean.toFixed(0)})</span>\n\t\t\t\t<span style=\"color: #66ff66;\">G: ${stats.g.min}-${stats.g.max} (${stats.g.mean.toFixed(0)})</span>\n\t\t\t\t<span style=\"color: #6666ff;\">B: ${stats.b.min}-${stats.b.max} (${stats.b.mean.toFixed(0)})</span>\n\t\t\t`;\n\t\t}\n\t}\n\n\t/**\n\t * Start dragging the overlay\n\t */\n\tstartDrag(e) {\n\t\tthis.isDragging = true;\n\t\tconst rect = this.overlay.getBoundingClientRect();\n\t\tthis.dragOffset = {\n\t\t\tx: e.clientX - rect.left,\n\t\t\ty: e.clientY - rect.top\n\t\t};\n\n\t\tconst onMouseMove = (e) => {\n\t\t\tif (!this.isDragging) return;\n\n\t\t\tconst x = e.clientX - this.dragOffset.x;\n\t\t\tconst y = e.clientY - this.dragOffset.y;\n\n\t\t\t// Keep within viewport bounds\n\t\t\tconst maxX = window.innerWidth - this.overlay.offsetWidth;\n\t\t\tconst maxY = window.innerHeight - this.overlay.offsetHeight;\n\n\t\t\tthis.overlay.style.left = Math.max(0, Math.min(x, maxX)) + 'px';\n\t\t\tthis.overlay.style.top = Math.max(0, Math.min(y, maxY)) + 'px';\n\t\t\tthis.overlay.style.right = 'auto';\n\t\t\tthis.overlay.style.bottom = 'auto';\n\t\t};\n\n\t\tconst onMouseUp = () => {\n\t\t\tthis.isDragging = false;\n\t\t\tdocument.removeEventListener('mousemove', onMouseMove);\n\t\t\tdocument.removeEventListener('mouseup', onMouseUp);\n\t\t};\n\n\t\tdocument.addEventListener('mousemove', onMouseMove);\n\t\tdocument.addEventListener('mouseup', onMouseUp);\n\n\t\te.preventDefault();\n\t}\n\n\t/**\n\t * Get current visibility state\n\t */\n\tgetVisibility() {\n\t\treturn this.isVisible;\n\t}\n}\n", "/**\n * Colormap Converter Module\n * Converts colormap images to float values based on selected colormap\n */\n\nexport class ColormapConverter {\n\tconstructor() {\n\t\t// Define common colormaps with 256 color entries (RGB values 0-255)\n\t\tthis.colormaps = this.initializeColormaps();\n\t}\n\n\t/**\n\t * Initialize colormap lookup tables\n\t * Each colormap is an array of 256 [r, g, b] values\n\t */\n\tinitializeColormaps() {\n\t\treturn {\n\t\t\tviridis: this.generateViridis(),\n\t\t\tplasma: this.generatePlasma(),\n\t\t\tinferno: this.generateInferno(),\n\t\t\tmagma: this.generateMagma(),\n\t\t\tjet: this.generateJet(),\n\t\t\thot: this.generateHot(),\n\t\t\tcool: this.generateCool(),\n\t\t\tturbo: this.generateTurbo(),\n\t\t\tgray: this.generateGray()\n\t\t};\n\t}\n\n\t/**\n\t * Convert a colormap image to float values\n\t * @param {ImageData} imageData - The source image data\n\t * @param {string} colormapName - Name of the colormap to use\n\t * @param {number} minValue - Minimum value to map to\n\t * @param {number} maxValue - Maximum value to map to\n\t * @param {boolean} inverted - Whether to invert the mapping\n\t * @param {boolean} logarithmic - Whether to use logarithmic mapping\n\t * @returns {Float32Array} Array of float values\n\t */\n\tconvertToFloat(imageData, colormapName, minValue, maxValue, inverted = false, logarithmic = false) {\n\t\tconst colormap = this.colormaps[colormapName];\n\t\tif (!colormap) {\n\t\t\tthrow new Error(`Unknown colormap: ${colormapName}`);\n\t\t}\n\n\t\tconst width = imageData.width;\n\t\tconst height = imageData.height;\n\t\tconst data = imageData.data;\n\t\tconst floatData = new Float32Array(width * height);\n\n\t\t// For each pixel, find the closest colormap entry\n\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\tconst pixelOffset = i * 4;\n\t\t\tconst r = data[pixelOffset];\n\t\t\tconst g = data[pixelOffset + 1];\n\t\t\tconst b = data[pixelOffset + 2];\n\n\t\t\t// Find closest colormap index\n\t\t\tlet index = this.findClosestColormapIndex(r, g, b, colormap);\n\n\t\t\t// Invert index if requested (255 -> 0, 0 -> 255)\n\t\t\tif (inverted) {\n\t\t\t\tindex = 255 - index;\n\t\t\t}\n\n\t\t\t// Map index (0-255) to normalized value (0-1)\n\t\t\tconst normalizedValue = index / 255.0;\n\n\t\t\t// Apply mapping (linear or logarithmic)\n\t\t\tlet finalValue;\n\t\t\tif (logarithmic) {\n\t\t\t\t// Logarithmic mapping\n\t\t\t\t// We need to handle the case where minValue or maxValue could be negative or zero\n\t\t\t\t// For logarithmic mapping to work, we need positive values\n\t\t\t\tconst useLogMin = Math.abs(minValue) < 1e-10 ? 1e-10 : Math.abs(minValue);\n\t\t\t\tconst useLogMax = Math.abs(maxValue) < 1e-10 ? 1e-10 : Math.abs(maxValue);\n\n\t\t\t\t// Map from normalized (0-1) to logarithmic space\n\t\t\t\tconst logMin = Math.log10(useLogMin);\n\t\t\t\tconst logMax = Math.log10(useLogMax);\n\t\t\t\tconst logValue = logMin + normalizedValue * (logMax - logMin);\n\t\t\t\tfinalValue = Math.pow(10, logValue);\n\n\t\t\t\t// Restore sign if original values were negative\n\t\t\t\tif (minValue < 0 && maxValue < 0) {\n\t\t\t\t\tfinalValue = -finalValue;\n\t\t\t\t} else if (minValue < 0) {\n\t\t\t\t\t// Mixed sign range - interpolate sign\n\t\t\t\t\tfinalValue = minValue + normalizedValue * (maxValue - minValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Linear mapping\n\t\t\t\tfinalValue = minValue + normalizedValue * (maxValue - minValue);\n\t\t\t}\n\n\t\t\tfloatData[i] = finalValue;\n\t\t}\n\n\t\treturn floatData;\n\t}\n\n\t/**\n\t * Find the closest colormap index for a given RGB color\n\t * @param {number} r - Red value (0-255)\n\t * @param {number} g - Green value (0-255)\n\t * @param {number} b - Blue value (0-255)\n\t * @param {Array} colormap - Colormap lookup table\n\t * @returns {number} Index of closest color (0-255)\n\t */\n\tfindClosestColormapIndex(r, g, b, colormap) {\n\t\tlet minDistance = Infinity;\n\t\tlet closestIndex = 0;\n\n\t\tfor (let i = 0; i < colormap.length; i++) {\n\t\t\tconst [cr, cg, cb] = colormap[i];\n\t\t\t// Euclidean distance in RGB space\n\t\t\tconst distance = Math.sqrt(\n\t\t\t\t(r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2\n\t\t\t);\n\n\t\t\tif (distance < minDistance) {\n\t\t\t\tminDistance = distance;\n\t\t\t\tclosestIndex = i;\n\t\t\t}\n\t\t}\n\n\t\treturn closestIndex;\n\t}\n\n\t// Colormap generation functions\n\t// Each generates 256 RGB values\n\n\tgenerateGray() {\n\t\tconst colormap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tcolormap.push([i, i, i]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\tgenerateJet() {\n\t\t// Classic jet colormap: blue -> cyan -> green -> yellow -> red\n\t\tconst colormap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst value = i / 255.0;\n\t\t\tlet r, g, b;\n\n\t\t\tif (value < 0.125) {\n\t\t\t\tr = 0;\n\t\t\t\tg = 0;\n\t\t\t\tb = 0.5 + value * 4;\n\t\t\t} else if (value < 0.375) {\n\t\t\t\tr = 0;\n\t\t\t\tg = (value - 0.125) * 4;\n\t\t\t\tb = 1;\n\t\t\t} else if (value < 0.625) {\n\t\t\t\tr = (value - 0.375) * 4;\n\t\t\t\tg = 1;\n\t\t\t\tb = 1 - (value - 0.375) * 4;\n\t\t\t} else if (value < 0.875) {\n\t\t\t\tr = 1;\n\t\t\t\tg = 1 - (value - 0.625) * 4;\n\t\t\t\tb = 0;\n\t\t\t} else {\n\t\t\t\tr = 1 - (value - 0.875) * 4;\n\t\t\t\tg = 0;\n\t\t\t\tb = 0;\n\t\t\t}\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(r * 255),\n\t\t\t\tMath.round(g * 255),\n\t\t\t\tMath.round(b * 255)\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\tgenerateHot() {\n\t\t// Hot colormap: black -> red -> orange -> yellow -> white\n\t\tconst colormap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst value = i / 255.0;\n\t\t\tlet r, g, b;\n\n\t\t\tif (value < 0.33) {\n\t\t\t\tr = value / 0.33;\n\t\t\t\tg = 0;\n\t\t\t\tb = 0;\n\t\t\t} else if (value < 0.66) {\n\t\t\t\tr = 1;\n\t\t\t\tg = (value - 0.33) / 0.33;\n\t\t\t\tb = 0;\n\t\t\t} else {\n\t\t\t\tr = 1;\n\t\t\t\tg = 1;\n\t\t\t\tb = (value - 0.66) / 0.34;\n\t\t\t}\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(r * 255),\n\t\t\t\tMath.round(g * 255),\n\t\t\t\tMath.round(b * 255)\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\tgenerateCool() {\n\t\t// Cool colormap: cyan -> magenta\n\t\tconst colormap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst value = i / 255.0;\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(value * 255),\n\t\t\t\tMath.round((1 - value) * 255),\n\t\t\t\t255\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\t// Viridis colormap (perceptually uniform)\n\tgenerateViridis() {\n\t\t// Simplified viridis - in production, use actual lookup table\n\t\tconst colormap = [];\n\t\tconst viridisData = [\n\t\t\t[0.267004, 0.004874, 0.329415],\n\t\t\t[0.282623, 0.140926, 0.457517],\n\t\t\t[0.253935, 0.265254, 0.529983],\n\t\t\t[0.206756, 0.371758, 0.553117],\n\t\t\t[0.163625, 0.471133, 0.558148],\n\t\t\t[0.127568, 0.566949, 0.550556],\n\t\t\t[0.134692, 0.658636, 0.517649],\n\t\t\t[0.266941, 0.748751, 0.440573],\n\t\t\t[0.477504, 0.821444, 0.318195],\n\t\t\t[0.741388, 0.873449, 0.149561],\n\t\t\t[0.993248, 0.906157, 0.143936]\n\t\t];\n\n\t\t// Interpolate to 256 colors\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst pos = (i / 255.0) * (viridisData.length - 1);\n\t\t\tconst idx = Math.floor(pos);\n\t\t\tconst frac = pos - idx;\n\n\t\t\tconst color1 = viridisData[Math.min(idx, viridisData.length - 1)];\n\t\t\tconst color2 = viridisData[Math.min(idx + 1, viridisData.length - 1)];\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(((color1[0] * (1 - frac) + color2[0] * frac) * 255)),\n\t\t\t\tMath.round(((color1[1] * (1 - frac) + color2[1] * frac) * 255)),\n\t\t\t\tMath.round(((color1[2] * (1 - frac) + color2[2] * frac) * 255))\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\t// Plasma colormap (perceptually uniform)\n\tgeneratePlasma() {\n\t\tconst colormap = [];\n\t\tconst plasmaData = [\n\t\t\t[0.050383, 0.029803, 0.527975],\n\t\t\t[0.287076, 0.010384, 0.627010],\n\t\t\t[0.476230, 0.011158, 0.657865],\n\t\t\t[0.647257, 0.125289, 0.593542],\n\t\t\t[0.785914, 0.274290, 0.472908],\n\t\t\t[0.877850, 0.439704, 0.345067],\n\t\t\t[0.936213, 0.605205, 0.231465],\n\t\t\t[0.972355, 0.771125, 0.155626],\n\t\t\t[0.994617, 0.938336, 0.165141],\n\t\t\t[0.987053, 0.991438, 0.749504]\n\t\t];\n\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst pos = (i / 255.0) * (plasmaData.length - 1);\n\t\t\tconst idx = Math.floor(pos);\n\t\t\tconst frac = pos - idx;\n\n\t\t\tconst color1 = plasmaData[Math.min(idx, plasmaData.length - 1)];\n\t\t\tconst color2 = plasmaData[Math.min(idx + 1, plasmaData.length - 1)];\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(((color1[0] * (1 - frac) + color2[0] * frac) * 255)),\n\t\t\t\tMath.round(((color1[1] * (1 - frac) + color2[1] * frac) * 255)),\n\t\t\t\tMath.round(((color1[2] * (1 - frac) + color2[2] * frac) * 255))\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\t// Inferno colormap (perceptually uniform)\n\tgenerateInferno() {\n\t\tconst colormap = [];\n\t\tconst infernoData = [\n\t\t\t[0.001462, 0.000466, 0.013866],\n\t\t\t[0.094329, 0.042852, 0.225802],\n\t\t\t[0.239903, 0.067979, 0.343397],\n\t\t\t[0.412470, 0.102815, 0.380271],\n\t\t\t[0.591217, 0.155410, 0.347824],\n\t\t\t[0.758643, 0.237267, 0.275196],\n\t\t\t[0.889650, 0.360829, 0.210001],\n\t\t\t[0.969788, 0.514135, 0.186861],\n\t\t\t[0.994738, 0.683489, 0.240902],\n\t\t\t[0.988362, 0.998364, 0.644924]\n\t\t];\n\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst pos = (i / 255.0) * (infernoData.length - 1);\n\t\t\tconst idx = Math.floor(pos);\n\t\t\tconst frac = pos - idx;\n\n\t\t\tconst color1 = infernoData[Math.min(idx, infernoData.length - 1)];\n\t\t\tconst color2 = infernoData[Math.min(idx + 1, infernoData.length - 1)];\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(((color1[0] * (1 - frac) + color2[0] * frac) * 255)),\n\t\t\t\tMath.round(((color1[1] * (1 - frac) + color2[1] * frac) * 255)),\n\t\t\t\tMath.round(((color1[2] * (1 - frac) + color2[2] * frac) * 255))\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\t// Magma colormap (perceptually uniform)\n\tgenerateMagma() {\n\t\tconst colormap = [];\n\t\tconst magmaData = [\n\t\t\t[0.001462, 0.000466, 0.013866],\n\t\t\t[0.091904, 0.051667, 0.200303],\n\t\t\t[0.234547, 0.090739, 0.348341],\n\t\t\t[0.408198, 0.131574, 0.416555],\n\t\t\t[0.595732, 0.180653, 0.421399],\n\t\t\t[0.776405, 0.266630, 0.373397],\n\t\t\t[0.924010, 0.406370, 0.330720],\n\t\t\t[0.987622, 0.583041, 0.382914],\n\t\t\t[0.996212, 0.771453, 0.543135],\n\t\t\t[0.987053, 0.991438, 0.749504]\n\t\t];\n\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst pos = (i / 255.0) * (magmaData.length - 1);\n\t\t\tconst idx = Math.floor(pos);\n\t\t\tconst frac = pos - idx;\n\n\t\t\tconst color1 = magmaData[Math.min(idx, magmaData.length - 1)];\n\t\t\tconst color2 = magmaData[Math.min(idx + 1, magmaData.length - 1)];\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(((color1[0] * (1 - frac) + color2[0] * frac) * 255)),\n\t\t\t\tMath.round(((color1[1] * (1 - frac) + color2[1] * frac) * 255)),\n\t\t\t\tMath.round(((color1[2] * (1 - frac) + color2[2] * frac) * 255))\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n\n\t// Turbo colormap (improved rainbow)\n\tgenerateTurbo() {\n\t\tconst colormap = [];\n\t\tconst turboData = [\n\t\t\t[0.18995, 0.07176, 0.23217],\n\t\t\t[0.25107, 0.25237, 0.63374],\n\t\t\t[0.19659, 0.47276, 0.82300],\n\t\t\t[0.12756, 0.66813, 0.82565],\n\t\t\t[0.13094, 0.82030, 0.65899],\n\t\t\t[0.37408, 0.92478, 0.41642],\n\t\t\t[0.66987, 0.95987, 0.19659],\n\t\t\t[0.90842, 0.87640, 0.10899],\n\t\t\t[0.98999, 0.64450, 0.03932],\n\t\t\t[0.93702, 0.25023, 0.01583]\n\t\t];\n\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tconst pos = (i / 255.0) * (turboData.length - 1);\n\t\t\tconst idx = Math.floor(pos);\n\t\t\tconst frac = pos - idx;\n\n\t\t\tconst color1 = turboData[Math.min(idx, turboData.length - 1)];\n\t\t\tconst color2 = turboData[Math.min(idx + 1, turboData.length - 1)];\n\n\t\t\tcolormap.push([\n\t\t\t\tMath.round(((color1[0] * (1 - frac) + color2[0] * frac) * 255)),\n\t\t\t\tMath.round(((color1[1] * (1 - frac) + color2[1] * frac) * 255)),\n\t\t\t\tMath.round(((color1[2] * (1 - frac) + color2[2] * frac) * 255))\n\t\t\t]);\n\t\t}\n\t\treturn colormap;\n\t}\n}\n", "// @ts-check\n\"use strict\";\n\nimport { SettingsManager } from './modules/settings-manager.js';\nimport { TiffProcessor } from './modules/tiff-processor.js';\nimport { ExrProcessor } from './modules/exr-processor.js';\nimport { NpyProcessor } from './modules/npy-processor.js';\nimport { PfmProcessor } from './modules/pfm-processor.js';\nimport { PpmProcessor } from './modules/ppm-processor.js';\nimport { PngProcessor } from './modules/png-processor.js';\nimport { ZoomController } from './modules/zoom-controller.js';\nimport { MouseHandler } from './modules/mouse-handler.js';\nimport { HistogramOverlay } from './modules/histogram-overlay.js';\nimport { ColormapConverter } from './modules/colormap-converter.js';\n\n/**\n * Main Image Preview Application\n * Orchestrates all modules to provide image viewing functionality\n */\n(function () {\n\t// @ts-ignore\n\tconst originalVscode = acquireVsCodeApi();\n\n\t// Format info tracking for context menu\n\tlet currentFormatInfo = null;\n\n\t// Wrap vscode.postMessage to track formatInfo\n\tconst vscode = {\n\t\tpostMessage: (message) => {\n\t\t\t// Track formatInfo when it's sent\n\t\t\tif (message.type === 'formatInfo' && message.value) {\n\t\t\t\tcurrentFormatInfo = message.value;\n\t\t\t}\n\t\t\treturn originalVscode.postMessage(message);\n\t\t},\n\t\tsetState: originalVscode.setState,\n\t\tgetState: originalVscode.getState\n\t};\n\n\t// Initialize all modules\n\tconst settingsManager = new SettingsManager();\n\tconst tiffProcessor = new TiffProcessor(settingsManager, vscode);\n\tconst exrProcessor = new ExrProcessor(settingsManager, vscode);\n\tconst zoomController = new ZoomController(settingsManager, vscode);\n\tconst mouseHandler = new MouseHandler(settingsManager, vscode, tiffProcessor);\n\tconst npyProcessor = new NpyProcessor(settingsManager, vscode);\n\tconst pfmProcessor = new PfmProcessor(settingsManager, vscode);\n\tconst ppmProcessor = new PpmProcessor(settingsManager, vscode);\n\tconst pngProcessor = new PngProcessor(settingsManager, vscode);\n\tconst histogramOverlay = new HistogramOverlay(settingsManager, vscode);\n\tconst colormapConverter = new ColormapConverter();\n\tmouseHandler.setNpyProcessor(npyProcessor);\n\tmouseHandler.setPfmProcessor(pfmProcessor);\n\tmouseHandler.setPpmProcessor(ppmProcessor);\n\tmouseHandler.setPngProcessor(pngProcessor);\n\tmouseHandler.setExrProcessor(exrProcessor);\n\n\t// Application state\n\tlet hasLoadedImage = false;\n\tlet canvas = null;\n\tlet imageElement = null;\n\tlet primaryImageData = null;\n\tlet peerImageData = null;\n\tlet peerImageUris = []; // Track peer URIs for comparison state\n\tlet isShowingPeer = false;\n\tlet initialLoadStartTime = 0;\n\tlet extensionLoadStartTime = 0; // Time when extension started loading (from settings)\n\tlet currentLoadFormat = '';\n\n\t// Colormap conversion state\n\tlet colormapConversionState = null;\n\n\t// Original image state (for reverting from conversions)\n\tlet originalImageData = null;\n\tlet hasAppliedConversion = false;\n\n\t// Restore persisted state if available\n\tconst persistedState = vscode.getState();\n\tif (persistedState) {\n\t\tpeerImageUris = persistedState.peerImageUris || [];\n\t\tisShowingPeer = persistedState.isShowingPeer || false;\n\t\tcolormapConversionState = persistedState.colormapConversionState || null;\n\t}\n\n\t// Image collection state\n\tlet imageCollection = {\n\t\ttotalImages: 1,\n\t\tcurrentIndex: 0,\n\t\tshow: false\n\t};\n\tlet overlayElement = null;\n\n\t/**\n\t * Save current state to VS Code webview state for persistence across tab switches\n\t */\n\tfunction saveState() {\n\t\t// Only save serializable state (no ImageData/Canvas objects)\n\t\tconst state = {\n\t\t\tpeerImageUris: peerImageUris,\n\t\t\tisShowingPeer: isShowingPeer,\n\t\t\tcurrentResourceUri: settingsManager.settings.resourceUri,\n\t\t\tcolormapConversionState: colormapConversionState,\n\t\t\ttimestamp: Date.now()\n\t\t};\n\t\tvscode.setState(state);\n\t}\n\n\t// DOM elements\n\tconst container = document.body;\n\tconst image = document.createElement('img');\n\n\t/**\n\t * Initialize the application\n\t */\n\tfunction initialize() {\n\t\tinitialLoadStartTime = performance.now();\n\t\t// Get the extension start time from settings (for total elapsed measurement)\n\t\textensionLoadStartTime = settingsManager.settings.loadStartTime || 0;\n\t\tsetupImageLoading();\n\t\tsetupMessageHandling();\n\t\tsetupEventListeners();\n\t\tcreateImageCollectionOverlay();\n\n\t\t// Save state when webview might be disposed\n\t\twindow.addEventListener('beforeunload', saveState);\n\t\twindow.addEventListener('pagehide', saveState);\n\n\t\t// Start loading the image\n\t\tconst settings = settingsManager.settings;\n\t\tconst resourceUri = settings.resourceUri;\n\n\t\t// Load image based on file extension\n\t\tif (resourceUri.toLowerCase().endsWith('.tif') || resourceUri.toLowerCase().endsWith('.tiff')) {\n\t\t\thandleTiff(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.exr')) {\n\t\t\thandleExr(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.pfm')) {\n\t\t\thandlePfm(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.ppm') || resourceUri.toLowerCase().endsWith('.pgm') || resourceUri.toLowerCase().endsWith('.pbm')) {\n\t\t\thandlePpm(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.png') || resourceUri.toLowerCase().endsWith('.jpg') || resourceUri.toLowerCase().endsWith('.jpeg')) {\n\t\t\thandlePng(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.npy') || resourceUri.toLowerCase().endsWith('.npz')) {\n\t\t\thandleNpy(settings.src);\n\t\t} else {\n\t\t\timage.src = settings.src;\n\t\t}\n\n\t\t// Restore comparison state if we have peer images\n\t\tif (peerImageUris.length > 0) {\n\t\t\t// Notify extension about restored peer images so it can update the image collection\n\t\t\tfor (const peerUri of peerImageUris) {\n\t\t\t\tvscode.postMessage({\n\t\t\t\t\ttype: 'restorePeerImage',\n\t\t\t\t\tpeerUri: peerUri\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Reload comparison images after main image loads\n\t\t\tsetTimeout(() => {\n\t\t\t\tfor (const peerUri of peerImageUris) {\n\t\t\t\t\thandleStartComparison(peerUri);\n\t\t\t\t}\n\t\t\t}, 1000); // Give main image time to load\n\t\t}\n\n\t\t// Restore colormap conversion if it was previously applied\n\t\tif (colormapConversionState) {\n\t\t\t// Wait for image to load, then reapply colormap conversion\n\t\t\t// Use polling to detect when image is ready to minimize visual flash\n\t\t\tconst checkAndApplyColormap = async () => {\n\t\t\t\tif (hasLoadedImage && canvas) {\n\t\t\t\t\t// Apply colormap conversion immediately\n\t\t\t\t\tawait handleColormapConversion(\n\t\t\t\t\t\tcolormapConversionState.colormapName,\n\t\t\t\t\t\tcolormapConversionState.minValue,\n\t\t\t\t\t\tcolormapConversionState.maxValue,\n\t\t\t\t\t\tcolormapConversionState.inverted,\n\t\t\t\t\t\tcolormapConversionState.logarithmic\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Check again in 50ms if not ready yet\n\t\t\t\t\tsetTimeout(checkAndApplyColormap, 50);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Start checking after a brief delay to allow initial setup\n\t\t\tsetTimeout(checkAndApplyColormap, 100);\n\t\t}\n\t}\n\n\t/**\n\t * Reload image when file changes on disk\n\t * Always resets zoom to 'fit' when file is rewritten to avoid dimension mismatch issues\n\t */\n\tfunction reloadImage() {\n\t\t// Reset the state\n\t\thasLoadedImage = false;\n\t\tcanvas = null;\n\t\timageElement = null;\n\t\tprimaryImageData = null;\n\t\tpeerImageData = null;\n\n\t\t// Clear stats in UI to prevent stale values\n\t\tvscode.postMessage({ type: 'stats', value: null });\n\n\t\t// Clear the container\n\t\tcontainer.className = 'container image';\n\n\t\t// Remove any existing image/canvas elements\n\t\tconst existingImages = container.querySelectorAll('img, canvas');\n\t\texistingImages.forEach(el => el.remove());\n\n\t\t// Remove loading indicator if present\n\t\tconst loadingIndicator = container.querySelector('.loading-indicator');\n\t\tif (loadingIndicator) {\n\t\t\tloadingIndicator.remove();\n\t\t}\n\n\t\t// Show loading state\n\t\tcontainer.classList.add('loading');\n\n\t\t// Load the image based on file type\n\t\tconst settings = settingsManager.settings;\n\t\tconst resourceUri = settings.resourceUri || '';\n\n\t\t// When file is rewritten, always reset zoom to 'fit' to avoid dimension mismatches\n\t\t// The file on disk may have changed size, so preserving zoom state would cause\n\t\t// incorrect calculations in zoomController.updateScale() which uses canvas.width/height\n\t\tzoomController.resetZoom();\n\n\t\t// Load image based on file extension\n\t\tif (resourceUri.toLowerCase().endsWith('.tif') || resourceUri.toLowerCase().endsWith('.tiff')) {\n\t\t\thandleTiff(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.pfm')) {\n\t\t\thandlePfm(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.ppm') || resourceUri.toLowerCase().endsWith('.pgm') || resourceUri.toLowerCase().endsWith('.pbm')) {\n\t\t\thandlePpm(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.png') || resourceUri.toLowerCase().endsWith('.jpg') || resourceUri.toLowerCase().endsWith('.jpeg')) {\n\t\t\thandlePng(settings.src);\n\t\t} else if (resourceUri.toLowerCase().endsWith('.npy') || resourceUri.toLowerCase().endsWith('.npz')) {\n\t\t\thandleNpy(settings.src);\n\t\t} else {\n\t\t\timage.src = settings.src || '';\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to send formatInfo (tracking happens automatically in vscode wrapper)\n\t */\n\tfunction sendFormatInfo(formatInfo) {\n\t\tvscode.postMessage({\n\t\t\ttype: 'formatInfo',\n\t\t\tvalue: formatInfo\n\t\t});\n\t}\n\n\t/**\n\t * Helper to log to VS Code Output\n\t */\n\tfunction logToOutput(message) {\n\t\tvscode.postMessage({\n\t\t\ttype: 'log',\n\t\t\tvalue: message\n\t\t});\n\t}\n\n\t/**\n\t * Setup image loading handlers\n\t */\n\tfunction setupImageLoading() {\n\t\tcontainer.classList.add('image');\n\t\timage.classList.add('scale-to-fit');\n\n\t\timage.addEventListener('load', () => {\n\t\t\tif (hasLoadedImage) return;\n\t\t\tonImageLoaded();\n\t\t});\n\n\t\timage.addEventListener('error', () => {\n\t\t\tif (hasLoadedImage) return;\n\t\t\tonImageError();\n\t\t});\n\t}\n\n\t/**\n\t * Handle successful image load\n\t */\n\tfunction onImageLoaded() {\n\t\thasLoadedImage = true;\n\n\t\t// Create a canvas and draw the image to it for unified rendering\n\t\tcanvas = document.createElement('canvas');\n\t\tcanvas.width = image.naturalWidth;\n\t\tcanvas.height = image.naturalHeight;\n\t\tcanvas.classList.add('scale-to-fit');\n\n\t\tconst ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tonImageError();\n\t\t\treturn;\n\t\t}\n\t\tctx.drawImage(image, 0, 0);\n\n\t\timageElement = canvas;\n\t\tfinalizeImageSetup();\n\t}\n\n\t/**\n\t * Handle image loading error\n\t */\n\tfunction onImageError() {\n\t\thasLoadedImage = true;\n\t\tcontainer.classList.add('error');\n\t\tcontainer.classList.remove('loading');\n\t}\n\n\t/**\n\t * Handle TIFF file loading\n\t */\n\tasync function handleTiff(src) {\n\t\tcurrentLoadFormat = 'TIFF';\n\t\ttry {\n\t\t\tconst result = await tiffProcessor.processTiff(src);\n\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\n\t\t\t// Draw the processed image data to canvas\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!tiffProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] TIFF Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling TIFF:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Handle EXR file loading\n\t */\n\tasync function handleExr(src) {\n\t\tcurrentLoadFormat = 'EXR';\n\t\ttry {\n\t\t\tconst result = await exrProcessor.processExr(src);\n\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\n\t\t\t// Draw the processed image data to canvas\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!exrProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] EXR Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling EXR:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Handle PFM file loading\n\t */\n\tasync function handlePfm(src) {\n\t\tcurrentLoadFormat = 'PFM';\n\t\ttry {\n\t\t\tconst result = await pfmProcessor.processPfm(src);\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!pfmProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] PFM Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling PFM:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Handle PPM/PGM file loading\n\t */\n\tasync function handlePpm(src) {\n\t\tcurrentLoadFormat = 'PPM/PGM';\n\t\ttry {\n\t\t\tconst result = await ppmProcessor.processPpm(src);\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!ppmProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] PPM/PGM Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling PPM/PGM:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Handle PNG/JPEG file loading\n\t */\n\tasync function handlePng(src) {\n\t\tcurrentLoadFormat = 'PNG/JPEG';\n\t\ttry {\n\t\t\tconst result = await pngProcessor.processPng(src);\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!pngProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] PNG/JPEG Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling PNG/JPEG:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Handle NPY/NPZ file loading\n\t */\n\tasync function handleNpy(src) {\n\t\tcurrentLoadFormat = 'NPY/NPZ';\n\t\ttry {\n\t\t\tconst result = await npyProcessor.processNpy(src);\n\t\t\tcanvas = result.canvas;\n\t\t\tprimaryImageData = result.imageData;\n\t\t\timageElement = canvas;\n\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.putImageData(primaryImageData, 0, 0);\n\t\t\t}\n\t\t\thasLoadedImage = true;\n\t\t\tfinalizeImageSetup();\n\n\t\t\tif (!npyProcessor._pendingRenderData) {\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\tlogToOutput(`[Perf] NPY/NPZ Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Error handling NPY/NPZ:', error);\n\t\t\tonImageError();\n\t\t}\n\t}\n\n\t/**\n\t * Finalize image setup after loading\n\t */\n\tfunction finalizeImageSetup() {\n\t\t// Update all controllers with references\n\t\tzoomController.setImageElement(imageElement);\n\t\tzoomController.setCanvas(canvas);\n\t\tzoomController.setImageLoaded();\n\t\tmouseHandler.setImageElement(imageElement);\n\n\t\t// Send size information to VS Code\n\t\tvscode.postMessage({\n\t\t\ttype: 'size',\n\t\t\tvalue: `${imageElement.width}x${imageElement.height}`,\n\t\t});\n\n\t\t// Update UI\n\t\tcontainer.classList.remove('loading');\n\t\tcontainer.classList.add('ready');\n\t\tcontainer.append(imageElement);\n\n\t\t// Apply initial zoom and setup mouse handling\n\t\tzoomController.applyInitialZoom();\n\t\tmouseHandler.addMouseListeners(imageElement);\n\n\t\t// Update histogram if visible\n\t\tupdateHistogramData();\n\t}\n\n\t/**\n\t * Setup VS Code message handling\n\t */\n\tfunction setupMessageHandling() {\n\t\twindow.addEventListener('message', async (e) => {\n\t\t\tif (e.origin !== window.origin) {\n\t\t\t\tconsole.error('Dropping message from unknown origin in image preview');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait handleVSCodeMessage(e.data);\n\t\t});\n\n\t\t// Send ready message to VS Code\n\t\tvscode.postMessage({ type: 'get-initial-data' });\n\t}\n\n\t/**\n\t * Handle messages from VS Code\n\t */\n\tasync function handleVSCodeMessage(message) {\n\t\tswitch (message.type) {\n\t\t\tcase 'setScale':\n\t\t\t\tzoomController.updateScale(message.scale);\n\t\t\t\tbreak;\n\n\t\t\tcase 'setActive':\n\t\t\t\tmouseHandler.setActive(message.value);\n\t\t\t\tbreak;\n\n\t\t\tcase 'zoomIn':\n\t\t\t\tzoomController.zoomIn();\n\t\t\t\tbreak;\n\n\t\t\tcase 'zoomOut':\n\t\t\t\tzoomController.zoomOut();\n\t\t\t\tbreak;\n\n\t\t\tcase 'resetZoom':\n\t\t\t\tzoomController.resetZoom();\n\t\t\t\tbreak;\n\n\t\t\tcase 'exportAsPng':\n\t\t\t\texportAsPng();\n\t\t\t\tbreak;\n\n\t\t\tcase 'start-comparison':\n\t\t\t\thandleStartComparison(message.peerUri);\n\t\t\t\tbreak;\n\n\t\t\tcase 'copyImage':\n\t\t\t\tcopyImage();\n\t\t\t\tbreak;\n\n\t\t\tcase 'updateSettings':\n\t\t\t\t// Handle real-time settings updates\n\t\t\t\tconst oldResourceUri = settingsManager.settings.resourceUri;\n\t\t\t\tconst changes = settingsManager.updateSettings(message.settings);\n\t\t\t\tconst newResourceUri = settingsManager.settings.resourceUri;\n\n\t\t\t\t// Check if this is a deferred render trigger (initial load)\n\t\t\t\tif (message.isInitialRender && canvas) {\n\t\t\t\t\t// Trigger deferred rendering for the appropriate processor\n\t\t\t\t\tlet deferredImageData = null;\n\n\t\t\t\t\tif (tiffProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = await tiffProcessor.performDeferredRender();\n\t\t\t\t\t} else if (npyProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = npyProcessor.performDeferredRender();\n\t\t\t\t\t} else if (pngProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = pngProcessor.performDeferredRender();\n\t\t\t\t\t} else if (ppmProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = ppmProcessor.performDeferredRender();\n\t\t\t\t\t} else if (pfmProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = pfmProcessor.performDeferredRender();\n\t\t\t\t\t} else if (exrProcessor._pendingRenderData) {\n\t\t\t\t\t\tdeferredImageData = exrProcessor.updateSettings(settingsManager.settings);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (deferredImageData) {\n\t\t\t\t\t\tconst ctx = canvas.getContext('2d', { willReadFrequently: true });\n\t\t\t\t\t\tif (ctx) {\n\t\t\t\t\t\t\tctx.putImageData(deferredImageData, 0, 0);\n\t\t\t\t\t\t\tprimaryImageData = deferredImageData;\n\t\t\t\t\t\t\tupdateHistogramData();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Log deferred render completion (only if we actually rendered deferred data)\n\t\t\t\t\t\tif (initialLoadStartTime > 0) {\n\t\t\t\t\t\t\tconst endTime = performance.now();\n\t\t\t\t\t\t\tconst webviewTime = (endTime - initialLoadStartTime).toFixed(2);\n\t\t\t\t\t\t\tconst totalTime = extensionLoadStartTime ? (Date.now() - extensionLoadStartTime) : webviewTime;\n\t\t\t\t\t\t\tlogToOutput(`[Perf] ${currentLoadFormat} Image loaded in ${webviewTime}ms (total: ${totalTime}ms)`);\n\t\t\t\t\t\t\tinitialLoadStartTime = 0; // Reset\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If resource URI changed, reload the entire image\n\t\t\t\telse if (oldResourceUri !== newResourceUri) {\n\t\t\t\t\t// Reload the image - zoom will be reset to 'fit' to handle dimension changes\n\t\t\t\t\treloadImage();\n\t\t\t\t} else {\n\t\t\t\t\t// Update rendering with new settings, using optimization hints\n\t\t\t\t\tconst startTime = performance.now();\n\t\t\t\t\tupdateImageWithNewSettings(changes);\n\t\t\t\t\tconst endTime = performance.now();\n\t\t\t\t\tlogToOutput(`[Perf] Re-render (Gamma/Brightness) took ${(endTime - startTime).toFixed(2)}ms`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'mask-filter-settings':\n\t\t\t\t// Handle mask filter settings updates\n\t\t\t\tconst maskChanges = settingsManager.updateSettings(message.settings);\n\t\t\t\tupdateImageWithNewSettings(maskChanges);\n\t\t\t\tbreak;\n\n\t\t\tcase 'updateImageCollectionOverlay':\n\t\t\t\tupdateImageCollectionOverlay(message.data);\n\t\t\t\tbreak;\n\n\t\t\tcase 'getZoomState':\n\t\t\t\t// Send current zoom state back to extension\n\t\t\t\tconst zoomState = zoomController.getCurrentState();\n\t\t\t\tvscode.postMessage({\n\t\t\t\t\ttype: 'zoomStateResponse',\n\t\t\t\t\tstate: zoomState\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'getComparisonState':\n\t\t\t\t// Send current comparison state back to extension\n\t\t\t\tconst comparisonState = {\n\t\t\t\t\tpeerUris: peerImageUris,\n\t\t\t\t\tisShowingPeer: isShowingPeer\n\t\t\t\t};\n\t\t\t\tvscode.postMessage({\n\t\t\t\t\ttype: 'comparisonStateResponse',\n\t\t\t\t\tstate: comparisonState\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'restoreZoomState':\n\t\t\t\t// Restore zoom state after image change\n\t\t\t\tif (message.state) {\n\t\t\t\t\tzoomController.restoreState(message.state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'restoreComparisonState':\n\t\t\t\t// Restore comparison state after image change\n\t\t\t\tif (message.state && message.state.peerUris && message.state.peerUris.length > 0) {\n\t\t\t\t\tpeerImageUris = message.state.peerUris;\n\t\t\t\t\tisShowingPeer = message.state.isShowingPeer;\n\n\t\t\t\t\t// Reload peer images for comparison\n\t\t\t\t\tfor (const peerUri of peerImageUris) {\n\t\t\t\t\t\thandleStartComparison(peerUri);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'switchToImage':\n\t\t\t\t// Switch to a different image\n\t\t\t\tswitchToNewImage(message.uri, message.resourceUri);\n\t\t\t\tbreak;\n\n\t\t\tcase 'toggleHistogram':\n\t\t\t\t// Toggle histogram visibility\n\t\t\t\thistogramOverlay.toggle();\n\t\t\t\tupdateHistogramData();\n\t\t\t\t// Notify extension of new state\n\t\t\t\tvscode.postMessage({\n\t\t\t\t\ttype: 'histogramVisibilityChanged',\n\t\t\t\t\tisVisible: histogramOverlay.getVisibility()\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'requestHistogram':\n\t\t\t\t// Extension requested histogram update\n\t\t\t\tupdateHistogramData();\n\t\t\t\tbreak;\n\n\t\t\tcase 'convertColormapToFloat':\n\t\t\t\t// Convert colormap image to float values\n\t\t\t\tawait handleColormapConversion(\n\t\t\t\t\tmessage.colormap,\n\t\t\t\t\tmessage.min,\n\t\t\t\t\tmessage.max,\n\t\t\t\t\tmessage.inverted || false,\n\t\t\t\t\tmessage.logarithmic || false\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase 'revertToOriginal':\n\t\t\t\t// Revert to the original image\n\t\t\t\thandleRevertToOriginal();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Update histogram with current image data\n\t */\n\tfunction updateHistogramData() {\n\t\tif (!canvas || !hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only update histogram if it's visible - this is expensive (~300-500ms for large images)\n\t\tif (!histogramOverlay.getVisibility()) {\n\n\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tconst ctx = canvas.getContext('2d', { willReadFrequently: true });\n\t\t\tif (!ctx) return;\n\n\t\t\t// Get current image data from canvas\n\t\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\t\t// Update histogram overlay\n\t\t\thistogramOverlay.update(imageData);\n\t\t} catch (error) {\n\t\t\tconsole.error('Error updating histogram:', error);\n\t\t}\n\t}\n\n\t/**\n\t * Convert colormap image to float values\n\t * @param {string} colormapName - Name of the colormap to use\n\t * @param {number} minValue - Minimum value to map to\n\t * @param {number} maxValue - Maximum value to map to\n\t * @param {boolean} inverted - Whether to invert the mapping\n\t * @param {boolean} logarithmic - Whether to use logarithmic mapping\n\t */\n\tasync function handleColormapConversion(colormapName, minValue, maxValue, inverted, logarithmic) {\n\t\tif (!canvas || !hasLoadedImage) {\n\t\t\tconsole.error('No image loaded for colormap conversion');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst ctx = canvas.getContext('2d', { willReadFrequently: true });\n\t\t\tif (!ctx) {\n\t\t\t\tconsole.error('Could not get canvas context');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the current image data from canvas\n\t\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\t\t// Convert to float using the colormap\n\t\t\tconst floatData = colormapConverter.convertToFloat(\n\t\t\t\timageData,\n\t\t\t\tcolormapName,\n\t\t\t\tminValue,\n\t\t\t\tmaxValue,\n\t\t\t\tinverted,\n\t\t\t\tlogarithmic\n\t\t\t);\n\n\t\t\t// Create a new ImageData for the float visualization\n\t\t\t// We'll render it as if it's a float TIFF\n\t\t\tconst width = imageData.width;\n\t\t\tconst height = imageData.height;\n\n\t\t\t// Store the float data for display\n\t\t\t// Create a temporary processor-like object to handle the float data\n\t\t\tconst floatImageData = new ImageData(width, height);\n\n\t\t\t// Enable auto-normalization and set the range\n\t\t\tif (settingsManager.settings.normalization) {\n\t\t\t\tsettingsManager.settings.normalization.autoNormalize = true;\n\t\t\t\tsettingsManager.settings.normalization.min = minValue;\n\t\t\t\tsettingsManager.settings.normalization.max = maxValue;\n\t\t\t}\n\n\t\t\t// Normalize float values to 0-255 for display\n\t\t\tfor (let i = 0; i < floatData.length; i++) {\n\t\t\t\tconst value = floatData[i];\n\t\t\t\t// Normalize to 0-255\n\t\t\t\tconst normalized = ((value - minValue) / (maxValue - minValue)) * 255;\n\t\t\t\tconst clamped = Math.max(0, Math.min(255, normalized));\n\n\t\t\t\tconst offset = i * 4;\n\t\t\t\tfloatImageData.data[offset] = clamped;     // R\n\t\t\t\tfloatImageData.data[offset + 1] = clamped; // G\n\t\t\t\tfloatImageData.data[offset + 2] = clamped; // B\n\t\t\t\tfloatImageData.data[offset + 3] = 255;     // A\n\t\t\t}\n\n\t\t\t// Display the converted float image\n\t\t\tctx.putImageData(floatImageData, 0, 0);\n\t\t\tprimaryImageData = floatImageData;\n\n\t\t\t// Force a visual update by triggering a reflow\n\t\t\t// This ensures the canvas changes are actually displayed\n\t\t\tif (imageElement === canvas) {\n\t\t\t\t// Canvas is already in DOM, force a repaint\n\t\t\t\tcanvas.style.display = 'none';\n\t\t\t\tcanvas.offsetHeight; // Trigger reflow\n\t\t\t\tcanvas.style.display = '';\n\t\t\t}\n\n\t\t\t// Update zoom controller to refresh the display\n\t\t\tzoomController.updateScale(zoomController.scale || 'fit');\n\n\t\t\t// Store the float data for pixel inspection\n\t\t\t// Store converted float data in a custom property (dynamic property)\n\t\t\t// @ts-ignore - Adding dynamic property for converted colormap data\n\t\t\ttiffProcessor._convertedFloatData = {\n\t\t\t\tfloatData: floatData,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tmin: minValue,\n\t\t\t\tmax: maxValue\n\t\t\t};\n\n\t\t\t// Clear the raw processor data to prevent re-rendering from original data\n\t\t\t// After colormap conversion, we want to work with the converted float data\n\t\t\ttiffProcessor.rawTiffData = null;\n\t\t\tif (exrProcessor) exrProcessor.rawExrData = null;\n\t\t\tif (npyProcessor) npyProcessor._lastRaw = null;\n\t\t\tif (ppmProcessor) ppmProcessor._lastRaw = null;\n\t\t\tif (pfmProcessor) pfmProcessor._lastRaw = null;\n\t\t\tif (pngProcessor) pngProcessor._lastRaw = null;\n\n\t\t\t// Update settings display\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: 'stats',\n\t\t\t\tvalue: { min: minValue, max: maxValue }\n\t\t\t});\n\n\t\t\t// Send format info\n\t\t\tsendFormatInfo({\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tbitsPerSample: 32,\n\t\t\t\tsampleFormat: 3, // Float\n\t\t\t\tsamplesPerPixel: 1,\n\t\t\t\tformatType: 'colormap-converted',\n\t\t\t\tisInitialLoad: false\n\t\t\t});\n\n\t\t\t// Update histogram\n\t\t\tupdateHistogramData();\n\n\t\t\t// Save the colormap conversion state for persistence\n\t\t\tcolormapConversionState = {\n\t\t\t\tcolormapName: colormapName,\n\t\t\t\tminValue: minValue,\n\t\t\t\tmaxValue: maxValue,\n\t\t\t\tinverted: inverted,\n\t\t\t\tlogarithmic: logarithmic\n\t\t\t};\n\t\t\thasAppliedConversion = true;\n\t\t\tsaveState();\n\n\t\t\tconsole.log(`Colormap conversion complete: ${colormapName} [${minValue}, ${maxValue}]`);\n\t\t} catch (error) {\n\t\t\tconsole.error('Error during colormap conversion:', error);\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: 'error',\n\t\t\t\tmessage: `Colormap conversion failed: ${error.message}`\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Revert to the original image before any conversions\n\t */\n\tfunction handleRevertToOriginal() {\n\t\tif (!canvas || !hasLoadedImage) {\n\t\t\tconsole.error('No image loaded to revert');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Reload the original image based on file type\n\t\t\tconst settings = settingsManager.settings;\n\t\t\tconst resourceUri = settings.resourceUri || '';\n\n\t\t\t// Reset the conversion state\n\t\t\tcolormapConversionState = null;\n\t\t\thasAppliedConversion = false;\n\t\t\toriginalImageData = null;\n\n\t\t\t// Clear converted data from processors\n\t\t\ttiffProcessor.rawTiffData = null;\n\t\t\tif (exrProcessor) exrProcessor.rawExrData = null;\n\t\t\tif (npyProcessor) npyProcessor._lastRaw = null;\n\t\t\tif (ppmProcessor) ppmProcessor._lastRaw = null;\n\t\t\tif (pfmProcessor) pfmProcessor._lastRaw = null;\n\t\t\tif (pngProcessor) pngProcessor._lastRaw = null;\n\t\t\t// @ts-ignore\n\t\t\ttiffProcessor._convertedFloatData = null;\n\n\t\t\t// Reload the image\n\t\t\treloadImage();\n\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: 'notifyRevert',\n\t\t\t\tmessage: 'Reverted to original image'\n\t\t\t});\n\n\t\t\tconsole.log('Reverted to original image');\n\t\t} catch (error) {\n\t\t\tconsole.error('Error reverting to original image:', error);\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: 'error',\n\t\t\t\tmessage: `Failed to revert to original image: ${error.message}`\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update image rendering with new settings\n\t * @param {Object} changes - What changed in settings (from settingsManager.updateSettings)\n\t */\n\tasync function updateImageWithNewSettings(changes) {\n\t\tif (!canvas || !hasLoadedImage) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Default to full update if no change info provided\n\t\tif (!changes) {\n\t\t\tchanges = { parametersOnly: false, changedMasks: false, changedStructure: false };\n\t\t}\n\n\t\t// If masks changed, clear the mask cache\n\t\tif (changes.changedMasks && tiffProcessor._maskCache) {\n\t\t\ttiffProcessor.clearMaskCache();\n\t\t}\n\n\t\t// For TIFF images, optimize based on what changed\n\t\tif (primaryImageData && tiffProcessor.rawTiffData) {\n\t\t\ttry {\n\t\t\t\t// If only parameters changed (gamma/brightness/normalization), use optimized path\n\t\t\t\tif (changes.parametersOnly) {\n\t\t\t\t\t// Skip mask loading and statistics recalculation\n\t\t\t\t\t// Just re-render with new parameters from raw data\n\t\t\t\t\tconst newImageData = await tiffProcessor.renderTiffWithSettingsFast(\n\t\t\t\t\t\ttiffProcessor.rawTiffData.image,\n\t\t\t\t\t\ttiffProcessor.rawTiffData.rasters,\n\t\t\t\t\t\ttrue // skipMasks flag\n\t\t\t\t\t);\n\n\t\t\t\t\t// Update the canvas with new image data\n\t\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\t\tif (ctx && newImageData) {\n\t\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\t\tupdateHistogramData();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Fallback to full re-render for structural changes or mask changes\n\t\t\t\tconst newImageData = await tiffProcessor.renderTiffWithSettings(\n\t\t\t\t\ttiffProcessor.rawTiffData.image,\n\t\t\t\t\ttiffProcessor.rawTiffData.rasters\n\t\t\t\t);\n\n\t\t\t\t// Update the canvas with new image data\n\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\tif (ctx && newImageData) {\n\t\t\t\t\tconsole.log('\u2705 CANVAS UPDATE (TIFF slow path): Applying new ImageData to canvas');\n\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\tupdateHistogramData();\n\t\t\t\t}\n\t\t\t\tconsole.log('\u2728 Slow path complete, returning');\n\t\t\t\treturn; // Don't fall through to other processors\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('\u274C Error updating TIFF image with new settings:', error);\n\t\t\t}\n\t\t\tconsole.log('\u21A9\uFE0F Returning after TIFF processing (even on error)');\n\t\t\treturn; // Return even on error to prevent fall-through\n\t\t}\n\n\t\t// Re-render based on which processor was used (mutually exclusive)\n\t\t// Check in order: EXR -> PGM -> PNG/JPEG -> NPY\n\n\t\t// For EXR images, re-render with new settings\n\t\tif (primaryImageData && exrProcessor && exrProcessor.rawExrData) {\n\t\t\tconsole.log('\uD83D\uDCC4 Processing EXR update');\n\t\t\ttry {\n\t\t\t\t// Re-render the EXR with current settings\n\t\t\t\tconst newImageData = exrProcessor.updateSettings(settingsManager.settings);\n\n\t\t\t\tif (newImageData) {\n\t\t\t\t\t// Update the canvas with new image data\n\t\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\t\tif (ctx) {\n\t\t\t\t\t\tconsole.log('\u2705 CANVAS UPDATE (EXR): Applying new ImageData to canvas');\n\t\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\t\tupdateHistogramData();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('\u274C Error updating EXR image with new settings:', error);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// For PGM images, re-render with new settings\n\t\telse if (primaryImageData && ppmProcessor && ppmProcessor._lastRaw) {\n\t\t\ttry {\n\t\t\t\t// Re-render the PGM with current settings\n\t\t\t\tconst newImageData = ppmProcessor.renderPgmWithSettings();\n\n\t\t\t\tif (newImageData) {\n\t\t\t\t\t// Update the canvas with new image data\n\t\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\t\tif (ctx) {\n\t\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\t\tupdateHistogramData();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error updating PGM image with new settings:', error);\n\t\t\t}\n\t\t}\n\t\t// For NPY images, re-render with new settings\n\t\telse if (primaryImageData && npyProcessor && npyProcessor._lastRaw) {\n\t\t\ttry {\n\t\t\t\t// Re-render the NPY with current settings\n\t\t\t\tconst newImageData = npyProcessor.renderNpyWithSettings();\n\n\t\t\t\tif (newImageData) {\n\t\t\t\t\t// Update the canvas with new image data\n\t\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\t\tif (ctx) {\n\t\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\t\tupdateHistogramData();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error updating NPY image with new settings:', error);\n\t\t\t}\n\t\t}\n\t\t// For PNG/JPEG images, re-render with new settings\n\t\telse if (primaryImageData && pngProcessor && pngProcessor._lastRaw) {\n\t\t\ttry {\n\t\t\t\t// Re-render the PNG with current settings\n\t\t\t\tconst newImageData = pngProcessor.renderPngWithSettings();\n\n\t\t\t\tif (newImageData) {\n\t\t\t\t\t// Update the canvas with new image data\n\t\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\t\tif (ctx) {\n\t\t\t\t\t\tctx.putImageData(newImageData, 0, 0);\n\t\t\t\t\t\tprimaryImageData = newImageData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error updating PNG/JPEG image with new settings:', error);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Setup additional event listeners\n\t */\n\tfunction setupEventListeners() {\n\t\t// Wheel zoom handling\n\t\tcontainer.addEventListener('wheel', (e) => {\n\t\t\t// Prevent pinch to zoom\n\t\t\tif (e.ctrlKey) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\tconst keyState = mouseHandler.getKeyboardState();\n\t\t\tzoomController.handleWheelZoom(e, keyState.ctrlPressed, keyState.altPressed);\n\t\t}, { passive: false });\n\n\t\t// Mouse click handling for zoom\n\t\tcontainer.addEventListener('mousedown', (e) => {\n\t\t\tif (!imageElement || !hasLoadedImage) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (e.button !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst keyState = mouseHandler.getKeyboardState();\n\t\t\tmouseHandler.consumeClick = !mouseHandler.isActive;\n\t\t});\n\n\t\tcontainer.addEventListener('click', (e) => {\n\t\t\tif (!imageElement || !hasLoadedImage) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (e.button !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (mouseHandler.consumeClick) {\n\t\t\t\tmouseHandler.consumeClick = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// left click zoom\n\t\t\tif (zoomController.scale === 'fit') {\n\t\t\t\tzoomController.firstZoom();\n\t\t\t}\n\n\t\t\tconst keyState = mouseHandler.getKeyboardState();\n\t\t\tif (!(settingsManager.isMac ? keyState.altPressed : keyState.ctrlPressed)) { // zoom in\n\t\t\t\tzoomController.zoomIn();\n\t\t\t} else {\n\t\t\t\tzoomController.zoomOut();\n\t\t\t}\n\t\t});\n\n\t\t// Scroll state saving\n\t\twindow.addEventListener('scroll', () => {\n\t\t\tif (!imageElement || !hasLoadedImage || !imageElement.parentElement || zoomController.scale === 'fit') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst entry = vscode.getState();\n\t\t\tif (entry) {\n\t\t\t\tvscode.setState({ scale: entry.scale, offsetX: window.scrollX, offsetY: window.scrollY });\n\t\t\t}\n\t\t}, { passive: true });\n\n\t\t// Copy handling\n\t\tdocument.addEventListener('copy', () => {\n\t\t\tcopyImage();\n\t\t});\n\n\t\t// Custom context menu with various commands\n\t\tdocument.addEventListener('contextmenu', (e) => {\n\t\t\te.preventDefault();\n\n\t\t\t// Remove any existing custom context menu\n\t\t\tconst existingMenu = document.querySelector('.custom-context-menu');\n\t\t\tif (existingMenu) {\n\t\t\t\texistingMenu.remove();\n\t\t\t}\n\n\t\t\t// Create custom context menu\n\t\t\tconst menu = document.createElement('div');\n\t\t\tmenu.className = 'custom-context-menu';\n\t\t\tmenu.style.left = `${e.clientX}px`;\n\t\t\tmenu.style.top = `${e.clientY}px`;\n\n\t\t\t// Helper function to create menu items\n\t\t\tconst createMenuItem = (text, action) => {\n\t\t\t\tconst item = document.createElement('div');\n\t\t\t\titem.className = 'context-menu-item';\n\t\t\t\titem.textContent = text;\n\t\t\t\titem.addEventListener('click', (e) => {\n\t\t\t\t\te.stopPropagation(); // Prevent event bubbling\n\t\t\t\t\tmenu.remove();\n\t\t\t\t\t// Execute action after removing menu to avoid timing issues\n\t\t\t\t\tsetTimeout(() => action(), 0);\n\t\t\t\t});\n\t\t\t\treturn item;\n\t\t\t};\n\n\t\t\t// Helper function to create separator\n\t\t\tconst createSeparator = () => {\n\t\t\t\tconst separator = document.createElement('div');\n\t\t\t\tseparator.className = 'context-menu-separator';\n\t\t\t\treturn separator;\n\t\t\t};\n\n\t\t\t// Add Copy option (triggers command via extension for logging)\n\t\t\tmenu.appendChild(createMenuItem('Copy', () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.copyImage' });\n\t\t\t}));\n\n\t\t\t// Add Export as PNG option (triggers command via extension)\n\t\t\tmenu.appendChild(createMenuItem('Export as PNG', () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.exportAsPng' });\n\t\t\t}));\n\n\t\t\tmenu.appendChild(createSeparator());\n\n\t\t\t// Add Toggle Histogram option (triggers command via extension for logging)\n\t\t\tmenu.appendChild(createMenuItem('Toggle Histogram (beta)', () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.toggleHistogram' });\n\t\t\t}));\n\n\t\t\t// Check if image is RGB (3+ channels) for RGB-specific options\n\t\t\t// Only show for images that we know are RGB (need formatInfo)\n\t\t\tconst isRgbImage = currentFormatInfo && currentFormatInfo.samplesPerPixel >= 3;\n\n\t\t\tif (isRgbImage) {\n\t\t\t\tmenu.appendChild(createSeparator());\n\n\t\t\t\t// Add Convert Colormap to Float option (uses command - needs user input)\n\t\t\t\tmenu.appendChild(createMenuItem('Convert Colormap to Float', () => {\n\t\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.convertColormapToFloat' });\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Show revert option if a colormap conversion has been applied\n\t\t\tif (hasAppliedConversion) {\n\t\t\t\tmenu.appendChild(createSeparator());\n\n\t\t\t\tmenu.appendChild(createMenuItem('Revert to Original', () => {\n\t\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.revertToOriginal' });\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tmenu.appendChild(createSeparator());\n\n\t\t\t// Add Filter by Mask option (uses command - needs user input)\n\t\t\tmenu.appendChild(createMenuItem('Filter by Mask (beta)', () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.filterByMask' });\n\t\t\t}));\n\n\n\t\t\tmenu.appendChild(createSeparator());\n\n\t\t\t// Add Open Comparison Panel option\n\t\t\t// menu.appendChild(createMenuItem('Open Comparison Panel', () => {\n\t\t\t// \tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.openComparisonPanel' });\n\t\t\t// }));\n\n\t\t\t// Add Toggle NaN Color option\n\t\t\tconst currentNanColor = settingsManager.settings.nanColor || 'black';\n\t\t\tconst nextNanColor = currentNanColor === 'black' ? 'fuchsia' : 'black';\n\t\t\tmenu.appendChild(createMenuItem(`Show NaN Color as ${nextNanColor}`, () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.toggleNanColor' });\n\t\t\t}));\n\n\t\t\t// Add Toggle Color Picker Mode option\n\t\t\tconst isShowingModified = settingsManager.settings.colorPickerShowModified || false;\n\t\t\tconst nextColorMode = isShowingModified ? 'Original Values' : 'Modified Values';\n\t\t\tmenu.appendChild(createMenuItem(`Color Picker: Show ${nextColorMode}`, () => {\n\t\t\t\tvscode.postMessage({ type: 'executeCommand', command: 'tiffVisualizer.toggleColorPickerMode' });\n\t\t\t}));\n\t\t\tdocument.body.appendChild(menu);\n\n\t\t\t// Remove menu when clicking outside\n\t\t\tconst removeMenu = (event) => {\n\t\t\t\tif (!menu.contains(event.target)) {\n\t\t\t\t\tmenu.remove();\n\t\t\t\t\tdocument.removeEventListener('click', removeMenu);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Use setTimeout to avoid immediate removal\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.addEventListener('click', removeMenu);\n\t\t\t}, 0);\n\t\t});\n\n\t\t// Prevent cut and paste operations (only copy makes sense for image viewer)\n\t\tdocument.addEventListener('cut', (e) => {\n\t\t\te.preventDefault();\n\t\t});\n\n\t\tdocument.addEventListener('paste', (e) => {\n\t\t\te.preventDefault();\n\t\t});\n\n\t\t// Comparison toggle\n\t\tdocument.addEventListener('keydown', (e) => {\n\t\t\tif (e.key === 'c' && peerImageData) {\n\t\t\t\tisShowingPeer = !isShowingPeer;\n\t\t\t\tconst imageData = isShowingPeer ? peerImageData : primaryImageData;\n\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\tif (ctx && imageData) {\n\t\t\t\t\tctx.putImageData(imageData, 0, 0);\n\t\t\t\t}\n\n\t\t\t\t// Save state after toggling comparison\n\t\t\t\tsaveState();\n\t\t\t}\n\t\t});\n\n\t\t// Error link handling\n\t\tdocument.querySelector('.open-file-link')?.addEventListener('click', (e) => {\n\t\t\te.preventDefault();\n\t\t\tvscode.postMessage({ type: 'reopen-as-text' });\n\t\t});\n\n\t\t// Keyboard handling for image toggling\n\t\twindow.addEventListener('keydown', (e) => {\n\t\t\tif (imageCollection.totalImages > 1) {\n\t\t\t\t// 't' key to toggle forward through images\n\t\t\t\tif (e.key.toLowerCase() === 't') {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvscode.postMessage({ type: 'toggleImage' });\n\t\t\t\t}\n\t\t\t\t// 'r' key to toggle backward through images\n\t\t\t\telse if (e.key.toLowerCase() === 'r') {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvscode.postMessage({ type: 'toggleImageReverse' });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Window beforeunload\n\t\twindow.addEventListener('beforeunload', () => {\n\t\t\tzoomController.saveState();\n\t\t});\n\t}\n\n\t/**\n\t * Create image collection overlay\n\t */\n\tfunction createImageCollectionOverlay() {\n\t\toverlayElement = document.createElement('div');\n\t\toverlayElement.classList.add('image-collection-overlay');\n\t\toverlayElement.style.display = 'none';\n\n\t\toverlayElement.innerHTML = `\n\t\t\t<div class=\"overlay-content\">\n\t\t\t\t<span class=\"image-counter\">1 of 1</span>\n\t\t\t\t<span class=\"toggle-hint\">Press 't'/'r' to navigate</span>\n\t\t\t</div>\n\t\t`;\n\n\t\tdocument.body.appendChild(overlayElement);\n\t}\n\n\t/**\n\t * Update image collection overlay\n\t */\n\tfunction updateImageCollectionOverlay(data) {\n\t\tif (!overlayElement) return;\n\n\t\timageCollection = data;\n\n\t\tif (data.show && data.totalImages > 1) {\n\t\t\tconst counter = overlayElement.querySelector('.image-counter');\n\t\t\tif (counter) {\n\t\t\t\tcounter.textContent = `${data.currentIndex + 1} of ${data.totalImages}`;\n\t\t\t}\n\t\t\toverlayElement.style.display = 'block';\n\t\t} else {\n\t\t\toverlayElement.style.display = 'none';\n\t\t}\n\t}\n\n\t/**\n\t * Switch to a new image in the collection (legacy - for fallback)\n\t */\n\tfunction switchToNewImage(uri, resourceUri) {\n\t\t// Update the settings with the new resource URI\n\t\tsettingsManager.settings.resourceUri = resourceUri;\n\t\tsettingsManager.settings.src = uri;\n\n\t\t// Reset the state\n\t\thasLoadedImage = false;\n\t\tcanvas = null;\n\t\timageElement = null;\n\t\tprimaryImageData = null;\n\n\t\t// Clear the container\n\t\tconst container = document.body;\n\t\tcontainer.className = 'container';\n\n\t\t// Remove any existing image/canvas elements\n\t\tconst existingImages = container.querySelectorAll('img, canvas');\n\t\texistingImages.forEach(el => el.remove());\n\n\t\t// Show loading state\n\t\tcontainer.classList.add('loading');\n\n\t\t// Load the new image based on file type\n\t\tloadImageByType(uri, resourceUri);\n\t}\n\n\t/**\n\t * Load image by type (wrapper function)\n\t */\n\tfunction loadImageByType(uri, resourceUri) {\n\t\tconst lower = resourceUri.toLowerCase();\n\t\tif (lower.endsWith('.tif') || lower.endsWith('.tiff')) {\n\t\t\thandleTiff(uri);\n\t\t} else if (lower.endsWith('.pfm')) {\n\t\t\thandlePfm(uri);\n\t\t} else if (lower.endsWith('.ppm') || lower.endsWith('.pgm') || lower.endsWith('.pbm')) {\n\t\t\thandlePpm(uri);\n\t\t} else if (lower.endsWith('.png') || lower.endsWith('.jpg') || lower.endsWith('.jpeg')) {\n\t\t\thandlePng(uri);\n\t\t} else if (lower.endsWith('.npy') || lower.endsWith('.npz')) {\n\t\t\thandleNpy(uri);\n\t\t} else {\n\t\t\t// Fallback to regular image loading\n\t\t\tconst newImage = document.createElement('img');\n\t\t\tnewImage.classList.add('scale-to-fit');\n\t\t\tnewImage.src = uri;\n\n\t\t\tnewImage.addEventListener('load', () => {\n\t\t\t\tif (hasLoadedImage) return;\n\n\t\t\t\t// Create canvas and draw image\n\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\tcanvas.width = newImage.naturalWidth;\n\t\t\t\tcanvas.height = newImage.naturalHeight;\n\t\t\t\tcanvas.classList.add('scale-to-fit');\n\n\t\t\t\tconst ctx = canvas.getContext('2d');\n\t\t\t\tif (ctx) {\n\t\t\t\t\tctx.drawImage(newImage, 0, 0);\n\t\t\t\t}\n\n\t\t\t\timageElement = canvas;\n\t\t\t\tfinalizeImageSetup();\n\t\t\t});\n\n\t\t\tnewImage.addEventListener('error', () => {\n\t\t\t\tif (hasLoadedImage) return;\n\t\t\t\tonImageError();\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Export canvas as PNG\n\t */\n\tfunction exportAsPng() {\n\t\tif (canvas) {\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: 'didExportAsPng',\n\t\t\t\tpayload: canvas.toDataURL('image/png')\n\t\t\t});\n\t\t} else if (image && image.src) {\n\t\t\t// If no canvas, create a temporary canvas from the image element\n\t\t\tconst tempCanvas = document.createElement('canvas');\n\t\t\ttempCanvas.width = image.naturalWidth;\n\t\t\ttempCanvas.height = image.naturalHeight;\n\t\t\tconst ctx = tempCanvas.getContext('2d');\n\t\t\tif (ctx) {\n\t\t\t\tctx.drawImage(image, 0, 0);\n\t\t\t\tvscode.postMessage({\n\t\t\t\t\ttype: 'didExportAsPng',\n\t\t\t\t\tpayload: tempCanvas.toDataURL('image/png')\n\t\t\t\t});\n\t\t\t\ttempCanvas.remove();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Show a notification message\n\t * @param {string} message - The message to display\n\t * @param {string} type - The type of notification ('success' or 'error')\n\t */\n\tfunction showNotification(message, type = 'success') {\n\t\t// Remove any existing notification\n\t\tconst existingNotification = document.querySelector('.copy-notification');\n\t\tif (existingNotification) {\n\t\t\texistingNotification.remove();\n\t\t}\n\n\t\t// Create notification element\n\t\tconst notification = document.createElement('div');\n\t\tnotification.className = `copy-notification copy-notification-${type}`;\n\t\tnotification.textContent = message;\n\n\t\t// Add to document\n\t\tdocument.body.appendChild(notification);\n\n\t\t// Auto-dismiss success notifications after 3 seconds\n\t\tif (type === 'success') {\n\t\t\tsetTimeout(() => {\n\t\t\t\tnotification.classList.add('copy-notification-fadeout');\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\t\tnotification.remove();\n\t\t\t\t\t}\n\t\t\t\t}, 300); // Match the CSS transition duration\n\t\t\t}, 3000);\n\t\t}\n\n\t\t// Allow manual dismissal by clicking\n\t\tnotification.addEventListener('click', () => {\n\t\t\tnotification.classList.add('copy-notification-fadeout');\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (notification.parentElement) {\n\t\t\t\t\tnotification.remove();\n\t\t\t\t}\n\t\t\t}, 300);\n\t\t});\n\t}\n\n\t/**\n\t * Copy image to clipboard\n\t */\n\tasync function copyImage(retries = 5) {\n\t\tif (!document.hasFocus() && retries > 0) {\n\t\t\tsetTimeout(() => { copyImage(retries - 1); }, 20);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if we have an image to copy\n\t\tif (!canvas && (!image || !image.naturalWidth)) {\n\t\t\tshowNotification('No image loaded to copy', 'error');\n\t\t\tconsole.error('Copy failed: No image available');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait navigator.clipboard.write([new ClipboardItem({\n\t\t\t\t'image/png': new Promise((resolve, reject) => {\n\t\t\t\t\tconst copyCanvas = document.createElement('canvas');\n\t\t\t\t\tconst ctx = copyCanvas.getContext('2d');\n\t\t\t\t\tif (!ctx) {\n\t\t\t\t\t\treturn reject(new Error('Could not get canvas context'));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canvas) {\n\t\t\t\t\t\tcopyCanvas.width = canvas.width;\n\t\t\t\t\t\tcopyCanvas.height = canvas.height;\n\t\t\t\t\t\tctx.drawImage(canvas, 0, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopyCanvas.width = image.naturalWidth;\n\t\t\t\t\t\tcopyCanvas.height = image.naturalHeight;\n\t\t\t\t\t\tctx.drawImage(image, 0, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyCanvas.toBlob((blob) => {\n\t\t\t\t\t\tif (blob) {\n\t\t\t\t\t\t\tresolve(blob);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treject(new Error('Could not create blob'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopyCanvas.remove();\n\t\t\t\t\t}, 'image/png');\n\t\t\t\t})\n\t\t\t})]);\n\n\t\t\t// Show success notification\n\t\t\tshowNotification('Image copied to clipboard', 'success');\n\t\t} catch (e) {\n\t\t\tconsole.error('Copy failed:', e);\n\t\t\tshowNotification(`Failed to copy image: ${e.message}`, 'error');\n\t\t}\n\t}\n\n\t/**\n\t * Handle comparison setup\n\t */\n\tasync function handleStartComparison(peerUri) {\n\t\ttry {\n\t\t\tvscode.postMessage({ type: 'show-loading' });\n\n\n\t\t\t// Track peer URI for state persistence\n\t\t\tif (!peerImageUris.includes(peerUri)) {\n\t\t\t\tpeerImageUris.push(peerUri);\n\t\t\t}\n\n\t\t\tconst result = await tiffProcessor.processTiff(peerUri);\n\t\t\tpeerImageData = result.imageData;\n\n\t\t\t// Save state after adding peer image\n\t\t\tsaveState();\n\n\t\t\tvscode.postMessage({ type: 'comparison-ready' });\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to load peer image for comparison:', error);\n\t\t\tvscode.postMessage({ type: 'show-error', message: 'Failed to load comparison image.' });\n\t\t}\n\t}\n\n\t// Start the application\n\tinitialize();\n}()); "],
  "mappings": "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",
  "names": ["ptr", "p", "range", "invRange", "decode_tiff", "decodeStart", "decodeTime", "width", "height", "samplesPerPixel", "bitsPerSample", "sampleFormat", "rasters", "data", "compression", "predictor", "photometricInterpretation", "planarConfig", "image", "canvas", "imageData", "totalTime", "pixelIndex", "data", "width", "height", "dtype", "showNorm", "channels", "canvas", "imageData", "e", "newImageData", "ctx", "e", "container"]
}
